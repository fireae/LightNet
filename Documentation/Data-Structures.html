<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Data Structures - LightNet</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link href="../css/codehilite.css" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap-3.0.3.min.js" defer></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../index.html">LightNet</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../index.html">Home</a>
                            </li>
                            <li >
                                <a href="../Getting-Started.html">Getting Started</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="Overview.html">Overview</a>
</li>
                                    
<li >
    <a href="Project-Structure.html">Project Structure</a>
</li>
                                    
<li >
    <a href="Build-Options.html">Build Options</a>
</li>
                                    
<li class="active">
    <a href="Data-Structures.html">Data Structures</a>
</li>
                                    
<li >
    <a href="Intermediate-Representation.html">Intermediate Representation</a>
</li>
                                    
<li >
    <a href="Operator-Description.html">Operator Description</a>
</li>
                                    
<li >
    <a href="Optimizer-Description.html">Optimizer Description</a>
</li>
                                    
<li >
    <a href="Miscellaneous.html">Miscellaneous</a>
</li>
                                </ul>
                            </li>
                            <li >
                                <a href="../Hacking.html">Hacking</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="Build-Options.html">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="Intermediate-Representation.html">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li>
                                <a href="https://github.com/zhaozhixu/LightNet"><i class="fa fa-github"></i> GitHub</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#data-structures">Data Structures</a></li>
            <li><a href="#linked-list">Linked List</a></li>
            <li><a href="#queue">Queue</a></li>
            <li><a href="#hash-table">Hash Table</a></li>
            <li><a href="#graph">Graph</a></li>
            <li><a href="#memory-model">Memory Model</a></li>
            <li><a href="#tensor">Tensor</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="data-structures">Data Structures<a class="headerlink" href="#data-structures" title="Permanent link">&para;</a></h1>
<h2 id="linked-list">Linked List<a class="headerlink" href="#linked-list" title="Permanent link">&para;</a></h2>
<p>LightNet uses <code>ln_list</code> to manage a sequence of data structures, which is a 
singlely linked list.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_list</span> <span class="p">{</span>
    <span class="kt">void</span>            <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">ln_list</span>  <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_list</span> <span class="n">ln_list</span><span class="p">;</span>
</pre></div>


<p><code>ln_list</code> doesn't have an empty header node; every node keeps real data.
It has no "create" functions. To create a new list, append an element to
a <code>NULL</code> list. Remember to always use the returned pointer as the newest
list pointer, because the first node may have changed during list alternation
(append, prepend, remove, insert, etc.).</p>
<div class="codehilite"><pre><span></span><span class="n">ln_list</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">list</span> <span class="o">=</span> <span class="n">ln_list_append</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">first_data</span><span class="p">);</span>
</pre></div>


<p>To traverse the list in order, use a <code>for</code> loop and a temporary variable to 
hold every element of the list, for example:</p>
<div class="codehilite"><pre><span></span><span class="cm">/* list is a ln_list of element type ln_op */</span>
<span class="n">ln_list</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
<span class="n">ln_op</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span> <span class="n">l</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="cm">/* operations on op */</span>
<span class="p">}</span>
</pre></div>


<p><code>ln_list</code> provides a macro for the convinence of traversing the list in order.
However, no list alternation shall be done when using this macro:</p>
<div class="codehilite"><pre><span></span><span class="cm">/* list is a ln_list of element type ln_op */</span>
<span class="n">ln_op</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
<span class="n">LN_LIST_FOREACH</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* op now hold one element of list */</span>
<span class="p">}</span>
</pre></div>


<p><code>ln_list</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_list *ln_list_prepend(ln_list *list, void *data)</code></strong></p>
<p>Prepend an element at the beginning of the list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_append(ln_list *list, void *data)</code></strong></p>
<p>Append an element at the end of the list.</p>
</li>
<li>
<p><strong><code>void ln_list_free(ln_list *list)</code></strong></p>
<p>Free all nodes in the list.</p>
</li>
<li>
<p><strong><code>void ln_list_free_deep(ln_list *list, void (*free_func)(void *))</code></strong></p>
<p>Free all nodes int the list as well as their elements, which are freed by
<code>free_func</code>.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_nth(ln_list *list, int n)</code></strong></p>
<p>Return the nth node in the list.</p>
</li>
<li>
<p><strong><code>void *ln_list_nth_data(ln_list *list, int n)</code></strong></p>
<p>Return the nth element in the list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove(ln_list *list, void *data)</code></strong></p>
<p>Remove the first node that has <code>data</code> as its element in the list. <code>data</code> is 
compared directly by the pointer value.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove_nth(ln_list *list, int n)</code></strong></p>
<p>Remove the nth node.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove_nth_deep(ln_list *list, int n, void (*free_func)(void *))</code></strong></p>
<p>Remove the nth node as well as its element, which is freed by <code>free_func</code>.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove_custom(ln_list *list, void *data, ln_cmp_func cmp)</code></strong></p>
<p>Remove the first node whose element can be compared with <code>data</code> by <code>cmp</code>
returning 0.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove_custom_deep(ln_list *list, void *data, ln_cmp_func cmp, void (*free_func)(void *))</code></strong></p>
<p>Remove the first node as well as its element which can be compared 
with <code>data</code> by <code>cmp</code> returning 0. The element is freed by <code>free_func</code>.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove_all_custom_deep(ln_list *list, void *data, ln_cmp_func cmp, void (*free_func)(void *))</code></strong></p>
<p>Remove all the nodes as well as their elements which can be compared 
with <code>data</code> by <code>cmp</code> returning 0. The elements are freed by <code>free_func</code>.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_insert_before(ln_list *list, void *data, ln_list *node)</code></strong></p>
<p>Insert an element <code>data</code> before <code>node</code> in the list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_insert_nth(ln_list *list, void *data, int n)</code></strong></p>
<p>Insert an element <code>data</code> at the nth position in the list.</p>
</li>
<li>
<p><strong><code>void *ln_list_find(ln_list *list, void *data)</code></strong></p>
<p>Find an element <code>data</code> in the list. <code>data</code> is compared directly by its 
pointer value. Return the element if it's found, else return <code>NULL</code>.</p>
</li>
<li>
<p><strong><code>void *ln_list_find_custom(ln_list *list, void *data, ln_cmp_func cmp)</code></strong></p>
<p>Find an element in the list, which can be compared with <code>data</code> by <code>cmp</code>
returning 0. Return the element if it's found, else return <code>NULL</code>.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_find_all_custom(ln_list *list, void *data, ln_cmp_func cmp)</code></strong></p>
<p>Find all elements that can be compared with <code>data</code> by <code>cmp</code> returning 0.
Return them in a new list.</p>
</li>
<li>
<p><strong><code>int ln_list_position(ln_list *list, ln_list *node)</code></strong></p>
<p>Return the position index of <code>node</code> in the list.</p>
</li>
<li>
<p><strong><code>int ln_list_index(ln_list *list, void *data)</code></strong></p>
<p>Return the position index of the first occurence of <code>data</code> in the list.
<code>data</code> is compared directly by its pointer value.</p>
</li>
<li>
<p><strong><code>int ln_list_index_custom(ln_list *list, void *data, ln_cmp_func cmp)</code></strong></p>
<p>Return the position index of the first node whose element can be compared
with <code>data</code> by <code>cmp</code> returning 0.</p>
</li>
<li>
<p><strong><code>int ln_list_length(ln_list *list)</code></strong></p>
<p>Return the length of the list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_reverse(ln_list *list)</code></strong></p>
<p>Reverse the nodes in the list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_from_array_size_t(size_t *array, size_t n)</code></strong></p>
<p>Create the list from an array with length <code>n</code>, whose elements are of type
<code>size_t</code>. The elements if the list have the same pointer values as the 
array's elements' values.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_copy(ln_list *list)</code></strong></p>
<p>Create a new list, whose elements' values are the same as <code>list</code>'s 
elements' values.</p>
</li>
</ul>
<h2 id="queue">Queue<a class="headerlink" href="#queue" title="Permanent link">&para;</a></h2>
<p><code>ln_queue</code> is a simple single-in single-out linked list, using two list nodes
for its head and tail.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_queue</span> <span class="p">{</span>
    <span class="n">ln_list</span>  <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="n">ln_list</span>  <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="kt">size_t</span>    <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_queue</span> <span class="n">ln_queue</span><span class="p">;</span>
</pre></div>


<p><code>ln_queue</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_queue *ln_queue_create(void)</code></strong></p>
<p>Create an empty queue.</p>
</li>
<li>
<p><strong><code>ln_queue *ln_queue_enqueue(ln_queue *queue, void *data)</code></strong></p>
<p>Add an element to the head of the queue. Create a new queue if 
<code>queue == NULL</code>.</p>
</li>
<li>
<p><strong><code>void *ln_queue_dequeue(ln_queue *queue)</code></strong></p>
<p>Remove and return the element at the tail of the queue.</p>
</li>
<li>
<p><strong><code>void ln_queue_free(ln_queue *queue)</code></strong></p>
<p>Free the queue.</p>
</li>
</ul>
<h2 id="hash-table">Hash Table<a class="headerlink" href="#hash-table" title="Permanent link">&para;</a></h2>
<p>LightNet uses <code>ln_hash</code> to construct key-value pairs that can be used for quick
lookups. <code>ln_hash</code> is an opaque structure in other modules. It uses separate
chaining method to store the key-value pairs, and its implementation references
the <a href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/9b8c96f96a0f/src/share/classes/java/util/HashMap.java">HashMap</a> in OpenJDK 7.</p>
<p><code>ln_hash</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_hash *ln_hash_create_full(ln_hash_func hash_func, ln_cmp_func cmp_func, ln_free_func free_k_func, ln_free_func free_v_func, int init_capacity, float load_factor)</code></strong></p>
<p>Create a hash table with full arguments.</p>
<p><code>hash_func</code> is the hash function of the key's data type.</p>
<p><code>cmp_func</code> is the comparison function of the key's data type.</p>
<p><code>free_k_func</code> is the free function of the key's data type. If it's <code>NULL</code>,
<code>ln_hash</code> will not free the key when it is removed.</p>
<p><code>free_v_func</code> is the free function of the value's data type. If it's <code>NULL</code>,
<code>ln_hash</code> will not free the value when it is removed.</p>
<p><code>init_capacity</code> is the initial capacity of the table.</p>
<p><code>load_factor</code> is the load factor of the table. When the ratio of the number
of elements to the capacity exceeds this factor, the table will expand its
capacity.</p>
</li>
<li>
<p><strong><code>ln_hash *ln_hash_create(ln_hash_func hash_func, ln_cmp_func cmp_func, ln_free_func free_k_func, ln_free_func free_v_func)</code></strong></p>
<p>Create a hash table with some default arguments.</p>
<p><code>hash_func</code> is the hash function of the key's data type.</p>
<p><code>cmp_func</code> is the comparison function of the key's data type.</p>
<p><code>free_k_func</code> is the free function of the key's data type. If it's <code>NULL</code>,
<code>ln_hash</code> will not free the key when it is removed.</p>
<p><code>free_v_func</code> is the free function of the value's data type. If it's <code>NULL</code>,
<code>ln_hash</code> will not free the value when it is removed.</p>
</li>
<li>
<p><strong><code>void ln_hash_free(ln_hash *hash)</code></strong></p>
<p>Free a hash table. Also free the keys and/or values if either of the free
functions is provided when creating this table.</p>
</li>
<li>
<p><strong><code>void ln_hash_init(ln_hash *hash, ln_hash_init_entry *init_array)</code></strong></p>
<p>Initialize an empty hash table with the key-value pairs in <code>init_array</code>. 
The elements of <code>init_array</code> are defined as:</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_hash_init_entry</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_hash_init_entry</span> <span class="n">ln_hash_init_entry</span><span class="p">;</span>
</pre></div>


<p>This array should be ended with a <code>{NULL, NULL}</code> entry.</p>
</li>
<li>
<p><strong><code>int ln_hash_insert(ln_hash *hash, const void *key, void *value)</code></strong></p>
<p>Insert a key-value pair to the hash table. Return 0 if the key already
exists and the old value is replaced by <code>value</code> (it will be freed if its
free function is provided when creating the table), else return 1.</p>
</li>
<li>
<p><strong><code>void *ln_hash_find(ln_hash *hash, const void *key)</code></strong></p>
<p>Find a value in the hash table with <code>key</code>. If it is found, return the value,
else return <code>NULL</code>. In case of existing legal <code>NULL</code> values, use 
<code>ln_hash_find_extended</code>.</p>
</li>
<li>
<p><strong><code>int ln_hash_find_extended(ln_hash *hash, const void *key, void **found_key, void **found_value)</code></strong></p>
<p>Find a value in the hash table with <code>key</code>. If it is found, return 1, else
return 0. The found key and value will be stored in <code>found_key</code> and 
<code>found_value</code> respectively. If either of <code>found_key</code> or <code>found_value</code> is
<code>NULL</code>, the found key or value will be ignored.</p>
</li>
<li>
<p><strong><code>int ln_hash_remove(ln_hash *hash, const void *key)</code></strong></p>
<p>Remove a key-value pair in the hash table. The key and/or value will also be
freed if either of the free functions is provided when creating the table.</p>
</li>
<li>
<p><strong><code>int ln_hash_size(ln_hash *hash)</code></strong></p>
<p>Return the number of key-value pairs in the hash table.</p>
</li>
</ul>
<h2 id="graph">Graph<a class="headerlink" href="#graph" title="Permanent link">&para;</a></h2>
<p>LightNet use <code>ln_graph</code> to represent computing graphs. <code>ln_graph</code> uses ajiacency
list method to implement directed graphs, which uses a linked list to store the
graph nodes; every node has its in-degree, out-degree,  a list of its previous
edges and nodes, and a list of its next edges and nodes.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_graph_node</span> <span class="p">{</span>
    <span class="kt">void</span>        <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="n">ln_list</span>     <span class="o">*</span><span class="n">out_edge_nodes</span><span class="p">;</span>    <span class="cm">/* data type is ln_graph_edge_node */</span>
    <span class="n">ln_list</span>     <span class="o">*</span><span class="n">in_edge_nodes</span><span class="p">;</span>
    <span class="n">ln_cmp_func</span>  <span class="n">node_data_cmp</span><span class="p">;</span>
    <span class="kt">size_t</span>       <span class="n">indegree</span><span class="p">;</span>
    <span class="kt">size_t</span>       <span class="n">outdegree</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_graph_node</span> <span class="n">ln_graph_node</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ln_graph_edge_node</span> <span class="p">{</span>         <span class="cm">/* store the ajiacency edge and node */</span>
    <span class="kt">void</span>           <span class="o">*</span><span class="n">edge_data</span><span class="p">;</span>
    <span class="n">ln_graph_node</span>  <span class="o">*</span><span class="n">node</span><span class="p">;</span>
    <span class="n">ln_cmp_func</span>     <span class="n">edge_data_cmp</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_graph_edge_node</span> <span class="n">ln_graph_edge_node</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ln_graph</span> <span class="p">{</span>
    <span class="kt">size_t</span>       <span class="n">size</span><span class="p">;</span>
    <span class="n">ln_list</span>     <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>             <span class="cm">/* data type is ln_graph_node */</span>
    <span class="n">ln_cmp_func</span>  <span class="n">node_data_cmp</span><span class="p">;</span>
    <span class="n">ln_cmp_func</span>  <span class="n">edge_data_cmp</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_graph</span> <span class="n">ln_graph</span><span class="p">;</span>
</pre></div>


<p><code>ln_graph</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_graph_node *ln_graph_node_create(void *data, ln_cmp_func node_data_cmp)</code></strong></p>
<p>Create a graph node with node data and the comparison function of node data.</p>
</li>
<li>
<p><strong><code>void ln_graph_node_free(ln_graph_node *node)</code></strong></p>
<p>Free a graph node.</p>
</li>
<li>
<p><strong><code>ln_graph_edge_node *ln_graph_edge_node_create(void *edge_data, ln_graph_node *node, ln_cmp_func edge_data_cmp)</code></strong></p>
<p>Create a graph edge node with edge data, the graph node, and the comparison
function of edge data.</p>
</li>
<li>
<p><strong><code>void ln_graph_edge_node_free(ln_graph_edge_node *edge_node)</code></strong></p>
<p>Free a graph edge node.</p>
</li>
<li>
<p><strong><code>ln_graph *ln_graph_create(ln_cmp_func node_cmp, ln_cmp_func edge_cmp)</code></strong></p>
<p>Create an empty graph with the comparison functions of node data and edge
data.</p>
</li>
<li>
<p><strong><code>void ln_graph_free(ln_graph *graph)</code></strong></p>
<p>Free a graph.</p>
</li>
<li>
<p><strong><code>ln_graph_node *ln_graph_add(ln_graph *graph, void *data)</code></strong></p>
<p>Create and add a node to the graph with <code>data</code> as node data. Return the 
created node.</p>
</li>
<li>
<p><strong><code>ln_graph_node *ln_graph_find(ln_graph *graph, void *data)</code></strong></p>
<p>Find the first graph node that has the same data as <code>data</code>. Return the found
node if the node is found, else return <code>NULL</code>.</p>
</li>
<li>
<p><strong><code>void ln_graph_link(ln_graph *graph, void *data1, void *data2, void *edge_data)</code></strong></p>
<p>Link the first node that has the same data as <code>data1</code> to the first node 
that has the same data as <code>data2</code>, with a newly created edge of <code>edge_data</code>.</p>
</li>
<li>
<p><strong><code>void ln_graph_link_node(ln_graph *graph, ln_graph_node *node1, ln_graph_node *node2, void *edge_data)</code></strong></p>
<p>Link <code>node1</code> to <code>node2</code> with a newly created edge of <code>edge_data</code>.</p>
</li>
<li>
<p><strong><code>void *ln_graph_unlink(ln_graph *graph, void *data1, void *data2, void *edge_data)</code></strong></p>
<p>Unlink the first node that has the same data as <code>data1</code> and the first node 
that has the same data as <code>data2</code>, with a edge of <code>edge_data</code>. If 
<code>edge_data == NULL</code>, only compare <code>data1</code> and <code>data2</code>.</p>
</li>
<li>
<p><strong><code>void *ln_graph_unlink_node(ln_graph_node *node1, ln_graph_node *node2, void *edge_data)</code></strong></p>
<p>Unlink <code>node1</code> and <code>node2</code> with a edge of <code>edge_data</code>. If
<code>edge_data == NULL</code>, only compare <code>data1</code> and <code>data2</code>.</p>
</li>
<li>
<p><strong><code>ln_graph *ln_graph_copy(ln_graph *graph)</code></strong></p>
<p>Copy a graph.</p>
</li>
<li>
<p><strong><code>int ln_graph_num_outlier(ln_graph *graph)</code></strong></p>
<p>Return the number of nodes that don't link with any other nodes.</p>
</li>
<li>
<p><strong><code>int ln_graph_topsort(ln_graph *graph, ln_list **layers)</code></strong></p>
<p>Run topological sort on the graph. Sorted nodes are returned in <code>layers</code>,
which is a pointer to a list of layers. All nodes in the same layer has the
topological order. 
Return -1 if the graph has a cycle, else return the number of layers.</p>
</li>
<li>
<p><strong><code>void ln_graph_free_topsortlist(ln_list *layers)</code></strong></p>
<p>Free the layers return by <code>ln_graph_topsort</code>.</p>
</li>
<li>
<p><strong><code>void ln_graph_fprint(FILE *fp, ln_graph *graph, ln_fprint_func print_node, ln_fprint_func print_edge)</code></strong></p>
<p>Print the graph to stream <code>fp</code>. Graph node data are printed by <code>print_node</code>.
Graph edge data are printed by <code>print_edge</code>.</p>
</li>
</ul>
<h2 id="memory-model">Memory Model<a class="headerlink" href="#memory-model" title="Permanent link">&para;</a></h2>
<p>Every computing device in heterogeneous platforms may have its own type of
memory. LightNet uses an enumeration type <code>ln_mem_type</code> to describe them.
Every <code>ln_mem_type</code> should have an instance of <code>ln_mem_info</code> in <code>ln_mem.c</code>.</p>
<div class="codehilite"><pre><span></span><span class="k">enum</span> <span class="n">ln_mem_type</span> <span class="p">{</span>
    <span class="n">LN_MEM_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">LN_MEM_CPU</span><span class="p">,</span>
<span class="cp">#ifdef LN_CUDA</span>
    <span class="n">LN_MEM_CUDA</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cm">/* ... may be other mem types here */</span>
    <span class="n">LN_MEM_TYPE_SIZE</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">ln_mem_type</span> <span class="n">ln_mem_type</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ln_mem_info</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">void</span>      <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc_func</span><span class="p">)(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
    <span class="kt">void</span>       <span class="p">(</span><span class="o">*</span><span class="n">free_func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
    <span class="kt">void</span>      <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">memset_func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
    <span class="kt">size_t</span>       <span class="n">max_size</span><span class="p">;</span>
    <span class="kt">size_t</span>       <span class="n">align_size</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_mem_info</span> <span class="n">ln_mem_info</span><span class="p">;</span>
</pre></div>


<p>Every <code>ln_mem_type</code> has its own information, in which <code>alloc_func</code>, 
<code>free_func</code>, <code>memset_func</code> are its memory operations, as <code>malloc</code>, <code>free</code>,
<code>memset</code> in the standard C library. <code>max_size</code> is the maximum bytes the memory
type can store. <code>align_size</code> is the alignment bytes the memory type requires.</p>
<p><code>ln_mem_type</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>const char *ln_mem_type_name(ln_mem_type mtype)</code></strong></p>
<p>Return the name of <code>mtype</code>.</p>
</li>
<li>
<p><strong><code>const ln_mem_info ln_mem_type_info(ln_mem_type mtype)</code></strong></p>
<p>Return the <code>ln_mem_info</code> of <code>mtype</code>.</p>
</li>
<li>
<p><strong><code>ln_copy_func ln_mem_type_copy_func(ln_mem_type dst_mtype, ln_mem_type src_mtype)</code></strong></p>
<p>Return the copy function from <code>src_mtype</code> to <code>dst_mtype</code>, as <code>memcpy</code> in the
standard C library.</p>
</li>
</ul>
<p>Besides, LightNet uses virtual memory pools to make overall arrangements for
memory allocations and releases. This step pre-plans the memory offsets of 
tensors, which can be converted to real memory addresses in run time.
<code>ln_mem_pool</code> is the virtual memory pool structure.</p>
<p><code>ln_mem_pool</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_mem_pool *ln_mem_pool_create(size_t size, size_t align_size)</code></strong></p>
<p>Create a virtual memory pool.</p>
</li>
<li>
<p><strong><code>void ln_mem_pool_free(ln_mem_pool *mem_pool)</code></strong></p>
<p>Free a virtual memory pool.</p>
</li>
<li>
<p><strong><code>size_t ln_mem_pool_alloc(ln_mem_pool *mem_pool, size_t size)</code></strong></p>
<p>Return the allocated memory offset (starting from 0) from the memory pool.</p>
</li>
<li>
<p><strong><code>void ln_mem_pool_dealloc(ln_mem_pool *mem_pool, size_t addr)</code></strong></p>
<p>Deallocate a memory offset.</p>
</li>
<li>
<p><strong><code>int ln_mem_pool_exist(ln_mem_pool *mem_pool, size_t addr)</code></strong></p>
<p>Test if a memory offset is allocated before.</p>
</li>
<li>
<p><strong><code>void ln_mem_pool_dump(ln_mem_pool *mem_pool, FILE *fp)</code></strong></p>
<p>Dump the memory layout of the memory pool.</p>
</li>
<li>
<p><strong><code>ln_hash *ln_mem_pool_table_create(void)</code></strong></p>
<p>Create a hash table of all memory pools. 
The table takes <code>ln_mem_type</code> as keys and <code>ln_mem_pool</code> as values.</p>
</li>
<li>
<p><strong><code>void ln_mem_pool_table_free(ln_hash *mpt)</code></strong></p>
<p>Free the memory pool hash table returned by <code>ln_mem_pool_table_create</code>.</p>
</li>
</ul>
<h2 id="tensor">Tensor<a class="headerlink" href="#tensor" title="Permanent link">&para;</a></h2>
<p>LightNet uses <code>ln_tensor</code> as the basic data storage structure.
<code>ln_tensor</code> further uses <a href="https://github.com/zhaozhixu/TensorLight">TensorLight</a>
as its basic tensor operation library, which is seperated from LightNet on
purpose so that it can be used widely beyond LightNet.</p>
<p>TensorLight implements many universal tensor operations. There are some simple
operations such as slice, transpose, concatation, relu, as well as some 
complicated operations such as bounding boxes' coordinate transformation,
YOLO's object detection. Developers are welcomed to add their own useful
operations to TensorLight, which can be used not only in LightNet, but also 
in other projects.</p>
<p>In both projects, a tensor refers to a <code>tl_tensor</code> structure, which has the
tensor's meta infomation and its data pointer.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">tl_tensor</span> <span class="p">{</span>
    <span class="n">tl_dtype</span>          <span class="n">dtype</span><span class="p">;</span>          <span class="cm">/* data type */</span>
    <span class="kt">int</span>               <span class="n">len</span><span class="p">;</span>            <span class="cm">/* number of elements */</span>
    <span class="kt">int</span>               <span class="n">ndim</span><span class="p">;</span>           <span class="cm">/* number of dimensions */</span>
    <span class="kt">int</span>              <span class="o">*</span><span class="n">dims</span><span class="p">;</span>           <span class="cm">/* array of dimensions */</span>
    <span class="kt">void</span>             <span class="o">*</span><span class="n">data</span><span class="p">;</span>           <span class="cm">/* data pointer */</span>
    <span class="k">struct</span> <span class="n">tl_tensor</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>          <span class="cm">/* data owner, NULL if it&#39;s itself */</span>
    <span class="kt">void</span>             <span class="o">*</span><span class="n">backend_data</span><span class="p">;</span>   <span class="cm">/* for other backend dependent data */</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tl_tensor</span> <span class="n">tl_tensor</span><span class="p">;</span>
</pre></div>


<p>A tensor's data type is represented by a enumeration type <code>tl_dtype</code>. It 
supports many common data types such as double, float, 32/16/8 bit 
signed/unsigned integers, and bool.</p>
<div class="codehilite"><pre><span></span><span class="k">enum</span> <span class="n">tl_dtype</span> <span class="p">{</span>
    <span class="n">TL_DTYPE_INVALID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">TL_DOUBLE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">TL_FLOAT</span><span class="p">,</span>
    <span class="n">TL_INT32</span><span class="p">,</span>
    <span class="n">TL_INT16</span><span class="p">,</span>
    <span class="n">TL_INT8</span><span class="p">,</span>
    <span class="n">TL_UINT32</span><span class="p">,</span>
    <span class="n">TL_UINT16</span><span class="p">,</span>
    <span class="n">TL_UINT8</span><span class="p">,</span>
    <span class="n">TL_BOOL</span><span class="p">,</span>
    <span class="n">TL_DTYPE_SIZE</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">tl_dtype</span> <span class="n">tl_dtype</span><span class="p">;</span>
</pre></div>


<p><code>tl_tensor</code> supports many tensor operations, see <a href="https://github.com/zhaozhixu/TensorLight">TensorLight</a> for more details.</p>
<p>In LightNet, all tensors in a NN model are managed by a tensor table. The tensor
table is a hash table, with tensors' names as its keys and tensor table entries
as its values. The tensor table entry structure is defined as follows.</p>
<div class="codehilite"><pre><span></span><span class="cm">/* NOTE: ALWAYS access tensor entry via its name in tensor table, since the</span>
<span class="cm">   entry may be not the same during passes. It is owned by the tensor table. */</span>
<span class="k">struct</span> <span class="n">ln_tensor_entry</span> <span class="p">{</span>
    <span class="kt">char</span>        <span class="o">*</span><span class="n">name</span><span class="p">;</span>          <span class="cm">/* tensor name */</span>
    <span class="n">tl_tensor</span>   <span class="o">*</span><span class="n">tensor</span><span class="p">;</span>        <span class="cm">/* pointer to the underlying tl_tensor */</span>
    <span class="kt">char</span>        <span class="o">*</span><span class="n">owner</span><span class="p">;</span>         <span class="cm">/* owner tensor&#39;s name of the tensor&#39;s data */</span>
    <span class="kt">char</span>        <span class="o">*</span><span class="n">creater</span><span class="p">;</span>       <span class="cm">/* operator name who creates the tensor */</span>
    <span class="kt">size_t</span>       <span class="n">offset</span><span class="p">;</span>        <span class="cm">/* offset address of the tensor&#39;s data */</span>
    <span class="kt">int</span>          <span class="n">isstatic</span><span class="p">;</span>      <span class="cm">/* the tensor is static or not */</span>
    <span class="n">ln_mem_type</span>  <span class="n">mtype</span><span class="p">;</span>         <span class="cm">/* memory type */</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_tensor_entry</span> <span class="n">ln_tensor_entry</span><span class="p">;</span>
</pre></div>


<p>Every tensor must be created by an operator, and <code>creater</code> records that
operator's name. Considering the computing efficiency, some tensors may share
the same underlying data pointer, in which case <code>owner</code> records the name of the
tensor who actually owns the data. <code>offset</code> is the relative address assigned to
the tensor in memory planning process, and it is initially 0, which is invalid 
at run time. Some tensors' memory may not be freed after allocation, in which
case <code>isstatic</code> should be labeled as 1 to indicate that it's static. Finally,
<code>mtype</code> is the memory type of the tensor's data.</p>
<p><code>ln_tensor_entry</code> supports the following operations:</p>
<ul>
<li><strong><code>ln_tensor_entry *ln_tensor_entry_create(const char *name, tl_tensor *tensor)</code></strong></li>
<li><strong><code>void ln_tensor_entry_free(ln_tensor_entry *entry)</code></strong></li>
<li><strong><code>void ln_tensor_entry_free_tensor_too(ln_tensor_entry *entry)</code></strong></li>
<li><strong><code>void ln_tensor_entry_set_owner(ln_tensor_entry *entry, ln_hash *tensor_table, char *direct_owner)</code></strong></li>
<li><strong><code>void ln_tensor_entry_set_creater(ln_tensor_entry *entry, const char *creater)</code></strong></li>
</ul>
<p>Besides tensor table entry, this mudule also defines a tensor list entry
structure <code>ln_tensor_list_entry</code>.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_tensor_list_entry</span> <span class="p">{</span>
    <span class="kt">char</span>            <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">char</span>            <span class="o">*</span><span class="n">arg_name</span><span class="p">;</span>
    <span class="kt">size_t</span>           <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_tensor_list_entry</span> <span class="n">ln_tensor_list_entry</span><span class="p">;</span>
</pre></div>


<p><code>ln_tensor_list_entry</code> is used in an operator's input/output tensor list. <code>name</code>
and <code>offset</code> are the same as those in the tensor's table entry. <code>name</code> is used
to find the tensor table entry from the operator. <code>offset</code> is used to store
the memory-planned address in the optimized output operator stream. <code>arg_name</code>
is the argument name of the tensor in the operator, such as "stride" in an 
"conv2d" operator.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "search": 83, "next": 78, "previous": 80};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../js/baidu_analyse.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
