<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Data Structures - LightNet</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link href="../css/codehilite.css" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap-3.0.3.min.js" defer></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../index.html">LightNet</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../index.html">Home</a>
                            </li>
                            <li >
                                <a href="../Getting-Started.html">Getting Started</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="Introduction.html">Introduction</a>
</li>
                                    
<li >
    <a href="Project-Structure.html">Project Structure</a>
</li>
                                    
<li >
    <a href="Build-Options.html">Build Options</a>
</li>
                                    
<li class="active">
    <a href="Data-Structures.html">Data Structures</a>
</li>
                                    
<li >
    <a href="Intermediate-Representation.html">Intermediate Representation</a>
</li>
                                    
<li >
    <a href="Intermediate-Language.html">Intermediate Language</a>
</li>
                                    
<li >
    <a href="Operator-Description.html">Operator Description</a>
</li>
                                    
<li >
    <a href="Optimizer-Description.html">Optimizer Description</a>
</li>
                                    
<li >
    <a href="Miscellaneous.html">Miscellaneous</a>
</li>
                                </ul>
                            </li>
                            <li >
                                <a href="../Hacking.html">Hacking</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="Build-Options.html">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="Intermediate-Representation.html">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li>
                                <a href="https://github.com/zhaozhixu/LightNet"><i class="fa fa-github"></i> GitHub</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#data-structures">Data Structures</a></li>
            <li><a href="#linked-list">Linked List</a></li>
            <li><a href="#queue">Queue</a></li>
            <li><a href="#stack">Stack</a></li>
            <li><a href="#hash-table">Hash Table</a></li>
            <li><a href="#graph">Graph</a></li>
            <li><a href="#memory-model">Memory Model</a></li>
            <li><a href="#tensor">Tensor</a></li>
            <li><a href="#parameter">Parameter</a></li>
            <li><a href="#operator">Operator</a></li>
            <li><a href="#data-flow-graph">Data Flow Graph</a></li>
            <li><a href="#context">Context</a></li>
            <li><a href="#architecture">Architecture</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="data-structures">Data Structures<a class="headerlink" href="#data-structures" title="Permanent link">&para;</a></h1>
<h2 id="linked-list">Linked List<a class="headerlink" href="#linked-list" title="Permanent link">&para;</a></h2>
<p>LightNet uses <code>ln_list</code> to manage a sequence of data structures, which is a 
singlely linked list.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_list</span> <span class="p">{</span>
    <span class="kt">void</span>            <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">ln_list</span>  <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_list</span> <span class="n">ln_list</span><span class="p">;</span>
</pre></div>


<p><code>ln_list</code> doesn't have an empty header node; every node keeps real data.
It has no "create" functions. To create a new list, append an element to
a <code>NULL</code> list. Remember to always use the returned pointer as the newest
list pointer, because the first node may have changed during list alternation
(append, prepend, remove, insert, etc.).</p>
<div class="codehilite"><pre><span></span><span class="n">ln_list</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">list</span> <span class="o">=</span> <span class="n">ln_list_append</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">first_data</span><span class="p">);</span>
</pre></div>


<p>To traverse the list in order, use a <code>for</code> loop and a temporary variable to 
hold every element of the list, for example:</p>
<div class="codehilite"><pre><span></span><span class="cm">/* list is a ln_list of element type ln_op */</span>
<span class="n">ln_list</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
<span class="n">ln_op</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span> <span class="n">l</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="cm">/* operations on op */</span>
<span class="p">}</span>
</pre></div>


<p><code>ln_list</code> provides a macro for the convinence of traversing the list in order.</p>
<div class="codehilite"><pre><span></span><span class="cm">/* list is a ln_list of element type ln_op */</span>
<span class="n">ln_op</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
<span class="n">LN_LIST_FOREACH</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* op now hold one element of list */</span>
<span class="p">}</span>
</pre></div>


<div class="admonition note">
<p class="admonition-title">Note</p>
<p>No list alternation shall be done when using <code>LN_LIST_FOREACH</code>.</p>
</div>
<p><code>ln_list</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_list *ln_list_prepend(ln_list *list, void *data)</code></strong></p>
<p>Prepend an element at the beginning of the list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_append(ln_list *list, void *data)</code></strong></p>
<p>Append an element at the end of the list.</p>
</li>
<li>
<p><strong><code>void ln_list_free(ln_list *list)</code></strong></p>
<p>Free all nodes in the list.</p>
</li>
<li>
<p><strong><code>void ln_list_free_deep(ln_list *list, void (*free_func)(void *))</code></strong></p>
<p>Free all nodes int the list as well as their elements, which are freed by
<code>free_func</code>.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_nth(ln_list *list, int n)</code></strong></p>
<p>Return the nth node in the list.</p>
</li>
<li>
<p><strong><code>void *ln_list_nth_data(ln_list *list, int n)</code></strong></p>
<p>Return the nth element in the list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove(ln_list *list, void *data)</code></strong></p>
<p>Remove the first node that has <code>data</code> as its element in the list. <code>data</code> is 
compared directly by the pointer value.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove_nth(ln_list *list, int n)</code></strong></p>
<p>Remove the nth node.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove_nth_deep(ln_list *list, int n, void (*free_func)(void *))</code></strong></p>
<p>Remove the nth node as well as its element, which is freed by <code>free_func</code>.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove_custom(ln_list *list, void *data, ln_cmp_func cmp)</code></strong></p>
<p>Remove the first node whose element can be compared with <code>data</code> by <code>cmp</code>
returning 0.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove_custom_deep(ln_list *list, void *data, ln_cmp_func cmp, void (*free_func)(void *))</code></strong></p>
<p>Remove the first node as well as its element which can be compared 
with <code>data</code> by <code>cmp</code> returning 0. The element is freed by <code>free_func</code>.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove_all_custom_deep(ln_list *list, void *data, ln_cmp_func cmp, void (*free_func)(void *))</code></strong></p>
<p>Remove all the nodes as well as their elements which can be compared 
with <code>data</code> by <code>cmp</code> returning 0. The elements are freed by <code>free_func</code>.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_insert_before(ln_list *list, void *data, ln_list *node)</code></strong></p>
<p>Insert an element <code>data</code> before <code>node</code> in the list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_insert_nth(ln_list *list, void *data, int n)</code></strong></p>
<p>Insert an element <code>data</code> at the nth position in the list.</p>
</li>
<li>
<p><strong><code>void *ln_list_find(ln_list *list, void *data)</code></strong></p>
<p>Find an element <code>data</code> in the list. <code>data</code> is compared directly by its 
pointer value. Return the element if it's found, else return <code>NULL</code>.</p>
</li>
<li>
<p><strong><code>void *ln_list_find_custom(ln_list *list, void *data, ln_cmp_func cmp)</code></strong></p>
<p>Find an element in the list, which can be compared with <code>data</code> by <code>cmp</code>
returning 0. Return the element if it's found, else return <code>NULL</code>.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_find_all_custom(ln_list *list, void *data, ln_cmp_func cmp)</code></strong></p>
<p>Find all elements that can be compared with <code>data</code> by <code>cmp</code> returning 0.
Return them in a new list.</p>
</li>
<li>
<p><strong><code>int ln_list_position(ln_list *list, ln_list *node)</code></strong></p>
<p>Return the position index of <code>node</code> in the list.</p>
</li>
<li>
<p><strong><code>int ln_list_index(ln_list *list, void *data)</code></strong></p>
<p>Return the position index of the first occurence of <code>data</code> in the list.
<code>data</code> is compared directly by its pointer value.</p>
</li>
<li>
<p><strong><code>int ln_list_index_custom(ln_list *list, void *data, ln_cmp_func cmp)</code></strong></p>
<p>Return the position index of the first node whose element can be compared
with <code>data</code> by <code>cmp</code> returning 0.</p>
</li>
<li>
<p><strong><code>int ln_list_length(ln_list *list)</code></strong></p>
<p>Return the length of the list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_reverse(ln_list *list)</code></strong></p>
<p>Reverse the nodes in the list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_from_array_size_t(size_t *array, size_t n)</code></strong></p>
<p>Create the list from an array with length <code>n</code>, whose elements are of type
<code>size_t</code>. The elements if the list have the same pointer values as the 
array's elements' values.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_copy(ln_list *list)</code></strong></p>
<p>Create a new list, whose elements' values are the same as <code>list</code>'s 
elements' values.</p>
</li>
</ul>
<h2 id="queue">Queue<a class="headerlink" href="#queue" title="Permanent link">&para;</a></h2>
<p><code>ln_queue</code> is a simple first-in first-out (FIFO) linked list, using two list nodes
for its head and tail.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_queue</span> <span class="p">{</span>
    <span class="n">ln_list</span>  <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="n">ln_list</span>  <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="kt">size_t</span>    <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_queue</span> <span class="n">ln_queue</span><span class="p">;</span>
</pre></div>


<p><code>ln_queue</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_queue *ln_queue_create(void)</code></strong></p>
<p>Create an empty queue.</p>
</li>
<li>
<p><strong><code>void ln_queue_free(ln_queue *queue)</code></strong></p>
<p>Free the queue.</p>
</li>
<li>
<p><strong><code>ln_queue *ln_queue_enqueue(ln_queue *queue, void *data)</code></strong></p>
<p>Add an element to the head of the queue. Create a new queue if 
<code>queue == NULL</code>.</p>
</li>
<li>
<p><strong><code>void *ln_queue_dequeue(ln_queue *queue)</code></strong></p>
<p>Remove and return the element at the tail of the queue.</p>
</li>
</ul>
<h2 id="stack">Stack<a class="headerlink" href="#stack" title="Permanent link">&para;</a></h2>
<p><code>ln_stack</code> is a simple first-in last-out (FILO) linked list, using a list node for
its top.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_stack</span> <span class="p">{</span>
    <span class="n">ln_list</span>  <span class="o">*</span><span class="n">top</span><span class="p">;</span>
    <span class="kt">size_t</span>    <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_stack</span> <span class="n">ln_stack</span><span class="p">;</span>
</pre></div>


<p><code>ln_stack</code> supports the following oeprations:</p>
<ul>
<li>
<p><strong><code>ln_stack *ln_stack_create(void)</code></strong></p>
<p>Create an empty stack.</p>
</li>
<li>
<p><strong><code>void ln_stack_free(ln_stack *stack)</code></strong></p>
<p>Free the stack.</p>
</li>
<li>
<p><strong><code>ln_stack *ln_stack_push(ln_stack *stack, void *data)</code></strong></p>
<p>Push an element to the top of the stack.</p>
</li>
<li>
<p><strong><code>void *ln_stack_pop(ln_stack *stack)</code></strong></p>
<p>Pop the top element out of the stack.</p>
</li>
</ul>
<h2 id="hash-table">Hash Table<a class="headerlink" href="#hash-table" title="Permanent link">&para;</a></h2>
<p>LightNet uses <code>ln_hash</code> to construct key-value pairs that can be used for quick
lookups. <code>ln_hash</code> is an opaque structure in other modules. It uses separate
chaining method to store the key-value pairs, and its implementation references
the <a href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/9b8c96f96a0f/src/share/classes/java/util/HashMap.java">HashMap</a> in OpenJDK 7.</p>
<p><code>ln_hash</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_hash *ln_hash_create_full(ln_hash_func hash_func, ln_cmp_func cmp_func, ln_free_func free_k_func, ln_free_func free_v_func, int init_capacity, float load_factor)</code></strong></p>
<p>Create a hash table with full arguments.</p>
<p><code>hash_func</code> is the hash function of the key's data type.</p>
<p><code>cmp_func</code> is the comparison function of the key's data type.</p>
<p><code>free_k_func</code> is the free function of the key's data type. If it's <code>NULL</code>,
<code>ln_hash</code> will not free the key when it is removed.</p>
<p><code>free_v_func</code> is the free function of the value's data type. If it's <code>NULL</code>,
<code>ln_hash</code> will not free the value when it is removed.</p>
<p><code>init_capacity</code> is the initial capacity of the table.</p>
<p><code>load_factor</code> is the load factor of the table. When the ratio of the number
of elements to the capacity exceeds this factor, the table will expand its
capacity.</p>
</li>
<li>
<p><strong><code>ln_hash *ln_hash_create(ln_hash_func hash_func, ln_cmp_func cmp_func, ln_free_func free_k_func, ln_free_func free_v_func)</code></strong></p>
<p>Create a hash table with some default arguments.</p>
<p><code>hash_func</code> is the hash function of the key's data type.</p>
<p><code>cmp_func</code> is the comparison function of the key's data type.</p>
<p><code>free_k_func</code> is the free function of the key's data type. If it's <code>NULL</code>,
<code>ln_hash</code> will not free the key when it is removed.</p>
<p><code>free_v_func</code> is the free function of the value's data type. If it's <code>NULL</code>,
<code>ln_hash</code> will not free the value when it is removed.</p>
</li>
<li>
<p><strong><code>void ln_hash_free(ln_hash *hash)</code></strong></p>
<p>Free a hash table. Also free the keys and/or values if either of the free
functions is provided when creating this table.</p>
</li>
<li>
<p><strong><code>void ln_hash_init(ln_hash *hash, ln_hash_init_entry *init_array)</code></strong></p>
<p>Initialize an empty hash table with the key-value pairs in <code>init_array</code>. 
The elements of <code>init_array</code> are defined as:</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_hash_init_entry</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_hash_init_entry</span> <span class="n">ln_hash_init_entry</span><span class="p">;</span>
</pre></div>


<p>This array should be ended with a <code>{NULL, NULL}</code> entry.</p>
</li>
<li>
<p><strong><code>int ln_hash_insert(ln_hash *hash, const void *key, void *value)</code></strong></p>
<p>Insert a key-value pair to the hash table. Return 0 if the key already
exists and the old value will be replaced by <code>value</code> (it will be freed if
its free function is provided when creating the table), else return 1.</p>
</li>
<li>
<p><strong><code>void *ln_hash_find(const ln_hash *hash, const void *key)</code></strong></p>
<p>Find a value in the hash table with <code>key</code>. If it is found, return the value,
else return <code>NULL</code>. In case of existing legal <code>NULL</code> values, use 
<code>ln_hash_find_extended</code>.</p>
</li>
<li>
<p><strong><code>int ln_hash_find_extended(const ln_hash *hash, const void *key, void **found_key, void **found_value)</code></strong></p>
<p>Find a value in the hash table with <code>key</code>. If it is found, return 1, else
return 0. The found key and value will be stored in <code>found_key</code> and 
<code>found_value</code> respectively. If either of <code>found_key</code> or <code>found_value</code> is
<code>NULL</code>, the found key or value will be ignored.</p>
</li>
<li>
<p><strong><code>int ln_hash_remove(ln_hash *hash, const void *key)</code></strong></p>
<p>Remove a key-value pair in the hash table. The key and/or value will also be
freed if either of the free functions is provided when creating the table.</p>
</li>
<li>
<p><strong><code>int ln_hash_size(ln_hash *hash)</code></strong></p>
<p>Return the number of key-value pairs in the hash table.</p>
</li>
</ul>
<h2 id="graph">Graph<a class="headerlink" href="#graph" title="Permanent link">&para;</a></h2>
<p>LightNet use <code>ln_graph</code> to represent computing graphs. <code>ln_graph</code> uses ajiacency
list method to implement directed graphs, which uses a linked list to store the
graph nodes; every node has its in-degree, out-degree,  a list of its previous
edges and nodes, and a list of its next edges and nodes.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_graph_node</span> <span class="p">{</span>
    <span class="kt">void</span>        <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="n">ln_list</span>     <span class="o">*</span><span class="n">out_edge_nodes</span><span class="p">;</span>    <span class="cm">/* data type is ln_graph_edge_node */</span>
    <span class="n">ln_list</span>     <span class="o">*</span><span class="n">in_edge_nodes</span><span class="p">;</span>
    <span class="n">ln_cmp_func</span>  <span class="n">node_data_cmp</span><span class="p">;</span>
    <span class="kt">size_t</span>       <span class="n">indegree</span><span class="p">;</span>
    <span class="kt">size_t</span>       <span class="n">outdegree</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_graph_node</span> <span class="n">ln_graph_node</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ln_graph_edge_node</span> <span class="p">{</span>         <span class="cm">/* store the ajiacency edge and node */</span>
    <span class="kt">void</span>           <span class="o">*</span><span class="n">edge_data</span><span class="p">;</span>
    <span class="n">ln_graph_node</span>  <span class="o">*</span><span class="n">node</span><span class="p">;</span>
    <span class="n">ln_cmp_func</span>     <span class="n">edge_data_cmp</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_graph_edge_node</span> <span class="n">ln_graph_edge_node</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ln_graph</span> <span class="p">{</span>
    <span class="kt">size_t</span>       <span class="n">size</span><span class="p">;</span>
    <span class="n">ln_list</span>     <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>             <span class="cm">/* data type is ln_graph_node */</span>
    <span class="n">ln_cmp_func</span>  <span class="n">node_data_cmp</span><span class="p">;</span>
    <span class="n">ln_cmp_func</span>  <span class="n">edge_data_cmp</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_graph</span> <span class="n">ln_graph</span><span class="p">;</span>
</pre></div>


<p><code>ln_graph</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_graph_node *ln_graph_node_create(void *data, ln_cmp_func node_data_cmp)</code></strong></p>
<p>Create a graph node with node data and the comparison function of node data.</p>
</li>
<li>
<p><strong><code>void ln_graph_node_free(ln_graph_node *node)</code></strong></p>
<p>Free a graph node.</p>
</li>
<li>
<p><strong><code>ln_graph_edge_node *ln_graph_edge_node_create(void *edge_data, ln_graph_node *node, ln_cmp_func edge_data_cmp)</code></strong></p>
<p>Create a graph edge node with edge data, the graph node, and the comparison
function of edge data.</p>
</li>
<li>
<p><strong><code>void ln_graph_edge_node_free(ln_graph_edge_node *edge_node)</code></strong></p>
<p>Free a graph edge node.</p>
</li>
<li>
<p><strong><code>ln_graph *ln_graph_create(ln_cmp_func node_cmp, ln_cmp_func edge_cmp)</code></strong></p>
<p>Create an empty graph with the comparison functions of node data and edge
data.</p>
</li>
<li>
<p><strong><code>void ln_graph_free(ln_graph *graph)</code></strong></p>
<p>Free a graph.</p>
</li>
<li>
<p><strong><code>ln_graph_node *ln_graph_add(ln_graph *graph, void *data)</code></strong></p>
<p>Create and add a node to the graph with <code>data</code> as node data. Return the 
created node.</p>
</li>
<li>
<p><strong><code>ln_graph_node *ln_graph_find(ln_graph *graph, void *data)</code></strong></p>
<p>Find the first graph node that has the same data as <code>data</code>. Return the found
node if the node is found, else return <code>NULL</code>.</p>
</li>
<li>
<p><strong><code>void ln_graph_link(ln_graph *graph, void *data1, void *data2, void *edge_data)</code></strong></p>
<p>Link the first node that has the same data as <code>data1</code> to the first node 
that has the same data as <code>data2</code>, with a newly created edge of <code>edge_data</code>.</p>
</li>
<li>
<p><strong><code>void ln_graph_link_node(ln_graph *graph, ln_graph_node *node1, ln_graph_node *node2, void *edge_data)</code></strong></p>
<p>Link <code>node1</code> to <code>node2</code> with a newly created edge of <code>edge_data</code>.</p>
</li>
<li>
<p><strong><code>void *ln_graph_unlink(ln_graph *graph, void *data1, void *data2, void *edge_data)</code></strong></p>
<p>Unlink the first node that has the same data as <code>data1</code> and the first node 
that has the same data as <code>data2</code>, with a edge of <code>edge_data</code>. If 
<code>edge_data == NULL</code>, only compare <code>data1</code> and <code>data2</code>.</p>
</li>
<li>
<p><strong><code>void *ln_graph_unlink_node(ln_graph_node *node1, ln_graph_node *node2, void *edge_data)</code></strong></p>
<p>Unlink <code>node1</code> and <code>node2</code> with a edge of <code>edge_data</code>. If
<code>edge_data == NULL</code>, only compare <code>data1</code> and <code>data2</code>.</p>
</li>
<li>
<p><strong><code>ln_graph *ln_graph_copy(ln_graph *graph)</code></strong></p>
<p>Copy a graph.</p>
</li>
<li>
<p><strong><code>int ln_graph_num_outlier(ln_graph *graph)</code></strong></p>
<p>Return the number of nodes that don't link with any other nodes.</p>
</li>
<li>
<p><strong><code>int ln_graph_topsort(ln_graph *graph, ln_list **layers)</code></strong></p>
<p>Run topological sort on the graph. Sorted nodes are returned in <code>layers</code>,
which is a pointer to a list of layers. All nodes in the same layer has the
topological order. 
Return -1 if the graph has a cycle, else return the number of layers.</p>
</li>
<li>
<p><strong><code>void ln_graph_free_topsortlist(ln_list *layers)</code></strong></p>
<p>Free the layers return by <code>ln_graph_topsort</code>.</p>
</li>
<li>
<p><strong><code>void ln_graph_fprint(FILE *fp, ln_graph *graph, ln_fprint_func print_node, ln_fprint_func print_edge)</code></strong></p>
<p>Print the graph to stream <code>fp</code>. Graph node data are printed by <code>print_node</code>.
Graph edge data are printed by <code>print_edge</code>.</p>
</li>
</ul>
<h2 id="memory-model">Memory Model<a class="headerlink" href="#memory-model" title="Permanent link">&para;</a></h2>
<p>Every computing device in heterogeneous platforms may have its own type of
memory. LightNet uses an enumeration type <code>ln_mem_type</code> to describe them.
Every <code>ln_mem_type</code> should have an instance of <code>ln_mem_info</code> in <code>ln_mem.c</code>.</p>
<div class="codehilite"><pre><span></span><span class="k">enum</span> <span class="n">ln_mem_type</span> <span class="p">{</span>
    <span class="n">LN_MEM_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">LN_MEM_CPU</span><span class="p">,</span>
<span class="cp">#ifdef LN_CUDA</span>
    <span class="n">LN_MEM_CUDA</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cm">/* ... may be other mem types here */</span>
    <span class="n">LN_MEM_TYPE_SIZE</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">ln_mem_type</span> <span class="n">ln_mem_type</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ln_mem_info</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">void</span>      <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc_func</span><span class="p">)(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
    <span class="kt">void</span>       <span class="p">(</span><span class="o">*</span><span class="n">free_func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
    <span class="kt">void</span>      <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">memset_func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
    <span class="kt">size_t</span>       <span class="n">max_size</span><span class="p">;</span>
    <span class="kt">size_t</span>       <span class="n">align_size</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_mem_info</span> <span class="n">ln_mem_info</span><span class="p">;</span>
</pre></div>


<p>Every <code>ln_mem_type</code> has its own information, in which <code>alloc_func</code>, 
<code>free_func</code>, <code>memset_func</code> are its memory operations, as <code>malloc</code>, <code>free</code>,
<code>memset</code> in the standard C library. <code>max_size</code> is the maximum bytes the memory
type can store. <code>align_size</code> is the alignment bytes the memory type requires.</p>
<p><code>ln_mem_type</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>const char *ln_mem_type_name(ln_mem_type mtype)</code></strong></p>
<p>Return the name of <code>mtype</code>.</p>
</li>
<li>
<p><strong><code>const ln_mem_info ln_mem_type_info(ln_mem_type mtype)</code></strong></p>
<p>Return the <code>ln_mem_info</code> of <code>mtype</code>.</p>
</li>
<li>
<p><strong><code>ln_copy_func ln_mem_type_copy_func(ln_mem_type dst_mtype, ln_mem_type src_mtype)</code></strong></p>
<p>Return the copy function from <code>src_mtype</code> to <code>dst_mtype</code>, as <code>memcpy</code> in the
standard C library.</p>
</li>
</ul>
<p>Besides, LightNet uses virtual memory pools to make overall arrangements for
the memory allocations and releases of all kinds of memory types.
This step pre-plans the memory offsets of tensors, which can be converted to 
real memory addresses in run time.
<code>ln_mem_pool</code> is the virtual memory pool structure.</p>
<p><code>ln_mem_pool</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_mem_pool *ln_mem_pool_create(size_t size, size_t align_size)</code></strong></p>
<p>Create a virtual memory pool.</p>
</li>
<li>
<p><strong><code>void ln_mem_pool_free(ln_mem_pool *mem_pool)</code></strong></p>
<p>Free a virtual memory pool.</p>
</li>
<li>
<p><strong><code>size_t ln_mem_pool_alloc(ln_mem_pool *mem_pool, size_t size)</code></strong></p>
<p>Return the allocated memory offset (starting from 0) from the memory pool.</p>
</li>
<li>
<p><strong><code>void ln_mem_pool_dealloc(ln_mem_pool *mem_pool, size_t addr)</code></strong></p>
<p>Deallocate a memory offset.</p>
</li>
<li>
<p><strong><code>int ln_mem_pool_exist(ln_mem_pool *mem_pool, size_t addr)</code></strong></p>
<p>Test if a memory offset is allocated before.</p>
</li>
<li>
<p><strong><code>void ln_mem_pool_dump(ln_mem_pool *mem_pool, FILE *fp)</code></strong></p>
<p>Dump the memory layout of the memory pool.</p>
</li>
<li>
<p><strong><code>ln_hash *ln_mem_pool_table_create(void)</code></strong></p>
<p>Create a hash table of all memory pools. 
The table takes <code>ln_mem_type</code> as keys and <code>ln_mem_pool</code> as values.</p>
</li>
<li>
<p><strong><code>void ln_mem_pool_table_free(ln_hash *mpt)</code></strong></p>
<p>Free the memory pool hash table returned by <code>ln_mem_pool_table_create</code>.</p>
</li>
</ul>
<h2 id="tensor">Tensor<a class="headerlink" href="#tensor" title="Permanent link">&para;</a></h2>
<p>LightNet uses <code>ln_tensor</code> as the basic data storage structure.
<code>ln_tensor</code> is used as operator's input and output, such as a
convolution's input image, output feature map, and weights.
<code>ln_tensor</code> further uses <a href="https://github.com/zhaozhixu/TensorLight">TensorLight</a>
as its basic tensor operation library, which is seperated from LightNet on
purpose so that it can be used widely beyond LightNet.</p>
<p>TensorLight implements many universal tensor operations. There are some simple
operations such as slice, transpose, concatation, relu, as well as some 
complicated operations such as bounding boxes' coordinate transformation,
YOLO's object detection. Developers are welcomed to add their own useful
operations to TensorLight, which can be used not only in LightNet, but also 
in other projects.</p>
<p>In both projects, a tensor refers to a <code>tl_tensor</code> structure, which has the
tensor's meta infomation and its data pointer.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">tl_tensor</span> <span class="p">{</span>
    <span class="n">tl_dtype</span>          <span class="n">dtype</span><span class="p">;</span>          <span class="cm">/* data type */</span>
    <span class="kt">int</span>               <span class="n">len</span><span class="p">;</span>            <span class="cm">/* number of elements */</span>
    <span class="kt">int</span>               <span class="n">ndim</span><span class="p">;</span>           <span class="cm">/* number of dimensions */</span>
    <span class="kt">int</span>              <span class="o">*</span><span class="n">dims</span><span class="p">;</span>           <span class="cm">/* array of dimensions */</span>
    <span class="kt">void</span>             <span class="o">*</span><span class="n">data</span><span class="p">;</span>           <span class="cm">/* data pointer */</span>
    <span class="k">struct</span> <span class="n">tl_tensor</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>          <span class="cm">/* data owner, NULL if it&#39;s itself */</span>
    <span class="kt">void</span>             <span class="o">*</span><span class="n">backend_data</span><span class="p">;</span>   <span class="cm">/* for other backend dependent data */</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tl_tensor</span> <span class="n">tl_tensor</span><span class="p">;</span>
</pre></div>


<p>A tensor's data type is represented by a enumeration type <code>tl_dtype</code>. It 
supports many common data types such as double, float, 32/16/8 bit 
signed/unsigned integers, and bool.</p>
<div class="codehilite"><pre><span></span><span class="k">enum</span> <span class="n">tl_dtype</span> <span class="p">{</span>
    <span class="n">TL_DTYPE_INVALID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">TL_DOUBLE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">TL_FLOAT</span><span class="p">,</span>
    <span class="n">TL_INT32</span><span class="p">,</span>
    <span class="n">TL_INT16</span><span class="p">,</span>
    <span class="n">TL_INT8</span><span class="p">,</span>
    <span class="n">TL_UINT32</span><span class="p">,</span>
    <span class="n">TL_UINT16</span><span class="p">,</span>
    <span class="n">TL_UINT8</span><span class="p">,</span>
    <span class="n">TL_BOOL</span><span class="p">,</span>
    <span class="n">TL_DTYPE_SIZE</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">tl_dtype</span> <span class="n">tl_dtype</span><span class="p">;</span>
</pre></div>


<p><code>tl_tensor</code> supports many tensor operations, see <a href="https://github.com/zhaozhixu/TensorLight">TensorLight</a> for more details.</p>
<p>In LightNet, all tensors in a NN model are managed by a tensor table. The tensor
table is a hash table, with tensors' names as its keys and tensor table entries
as its values. The tensor table entry structure is defined as follows.</p>
<div class="codehilite"><pre><span></span><span class="cm">/* NOTE: ALWAYS access tensor entry via its name in tensor table, since the</span>
<span class="cm">   entry may be not the same during passes. It is owned by the tensor table. */</span>
<span class="k">struct</span> <span class="n">ln_tensor_entry</span> <span class="p">{</span>
    <span class="kt">char</span>        <span class="o">*</span><span class="n">name</span><span class="p">;</span>          <span class="cm">/* tensor name */</span>
    <span class="n">tl_tensor</span>   <span class="o">*</span><span class="n">tensor</span><span class="p">;</span>        <span class="cm">/* pointer to the underlying tl_tensor */</span>
    <span class="kt">char</span>        <span class="o">*</span><span class="n">owner</span><span class="p">;</span>         <span class="cm">/* owner tensor&#39;s name of the tensor&#39;s data */</span>
    <span class="kt">char</span>        <span class="o">*</span><span class="n">creater</span><span class="p">;</span>       <span class="cm">/* operator name who creates the tensor */</span>
    <span class="kt">size_t</span>       <span class="n">offset</span><span class="p">;</span>        <span class="cm">/* offset address of the tensor&#39;s data */</span>
    <span class="kt">int</span>          <span class="n">isstatic</span><span class="p">;</span>      <span class="cm">/* the tensor is static or not */</span>
    <span class="n">ln_mem_type</span>  <span class="n">mtype</span><span class="p">;</span>         <span class="cm">/* memory type */</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_tensor_entry</span> <span class="n">ln_tensor_entry</span><span class="p">;</span>
</pre></div>


<p>Every tensor must be created by an operator, and <code>creater</code> records that
operator's name. Considering the computing efficiency, some tensors may share
the same underlying data pointer, in which case <code>owner</code> records the name of the
tensor who actually owns the data. <code>offset</code> is the relative address assigned to
the tensor in memory planning process, and it is initially 0, which is invalid 
at run time. Some tensors' memory may not be freed after allocation, in which
case <code>isstatic</code> should be labeled as 1 to indicate that it's static. Finally,
<code>mtype</code> is the memory type of the tensor's data.</p>
<p><code>ln_tensor_entry</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_tensor_entry *ln_tensor_entry_create(const char *name, tl_tensor *tensor)</code></strong></p>
<p>Create a tensor entry with <code>name</code> and the underlying <code>tensor</code>.</p>
</li>
<li>
<p><strong><code>void ln_tensor_entry_free(ln_tensor_entry *entry)</code></strong></p>
<p>Free a tensor entry.</p>
</li>
<li>
<p><strong><code>void ln_tensor_entry_free_tensor_too(ln_tensor_entry *entry)</code></strong></p>
<p>Free the tensor entry as well as the underlying <code>tensor</code>,
but not free the raw data pointer <code>tensor-&gt;data</code>.</p>
</li>
<li>
<p><strong><code>void ln_tensor_entry_set_owner(ln_tensor_entry *entry, ln_hash *tensor_table, char *owner)</code></strong></p>
<p>Set the owner tensor name to <code>owner</code> with which the tensor entry
shares its data.</p>
</li>
<li>
<p><strong><code>void ln_tensor_entry_set_creater(ln_tensor_entry *entry, const char *creater)</code></strong></p>
<p>Set the name of the creater operator of this tensor entry to <code>creater</code>.</p>
</li>
</ul>
<p>The tensor table supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_hash *ln_tensor_table_create(void)</code></strong></p>
<p>Create a tensor table.</p>
</li>
<li>
<p><strong><code>int ln_tensor_table_insert(ln_hash *table, ln_tensor_entry *entry)</code></strong></p>
<p>Insert a new tensor entry to the tensor table. The behaviour is consistent
with <code>ln_hash_insert()</code>.</p>
</li>
<li>
<p><strong><code>int ln_tensor_table_remove(ln_hash *table, const char *name)</code></strong></p>
<p>Remove a tensor entry <code>name</code> from the tensor table.</p>
</li>
<li>
<p><strong><code>ln_tensor_entry *ln_tensor_table_find(ln_hash *table, const char *name)</code></strong></p>
<p>Find a tensor entry <code>name</code> in the tensor table.</p>
</li>
<li>
<p><strong><code>void ln_tensor_table_free(ln_hash *table);</code></strong></p>
<p>Free the tensor table as well as all its tensor entries.</p>
</li>
<li>
<p><strong><code>void ln_tensor_table_set_data(ln_hash *table, const char *name, const void *data)</code></strong></p>
<p>Copy <code>data</code> to the underlying memory region of tensor entry <code>name</code>.</p>
</li>
<li>
<p><strong><code>void *ln_tensor_table_get_data(ln_hash *table, const char *name, void *data)</code></strong></p>
<p>Copy the underlying memory region of tensor entry <code>name</code> to <code>data</code>.</p>
</li>
<li>
<p><strong><code>size_t ln_tensor_table_data_size(ln_hash *table, const char *name)</code></strong></p>
<p>Get the data size of the tensor entry <code>name</code> in bytes.</p>
</li>
<li>
<p><strong><code>void ln_tensor_table_load_trt_weight_file(ln_hash *table, const char *file)</code></strong></p>
<p>Copy the weights from <code>file</code> to the tensor entries accordingly. <code>file</code>
should follow the weight format of TensorRT, which can be showned with
<code>tools/genwts.pl -h</code>.</p>
</li>
</ul>
<p>When removing a tensor or inserting a different tensor with the same name 
as another tensor, the tensor table will free the old table entry and its 
<code>tensor</code> field, but not free <code>tensor-&gt;data</code>. So we should always insert tensors 
with <code>NULL</code> data.</p>
<p>Besides tensor table entry, this mudule also defines a tensor list entry
structure <code>ln_tensor_list_entry</code>.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_tensor_list_entry</span> <span class="p">{</span>
    <span class="kt">char</span>            <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">char</span>            <span class="o">*</span><span class="n">arg_name</span><span class="p">;</span>
    <span class="kt">size_t</span>           <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_tensor_list_entry</span> <span class="n">ln_tensor_list_entry</span><span class="p">;</span>
</pre></div>


<p><code>ln_tensor_list_entry</code> is used in an operator's input/output tensor list. <code>name</code>
and <code>offset</code> are the same as those in the tensor's table entry. <code>name</code> is used
to find the tensor table entry from the operator. <code>offset</code> is used to store
the memory-planned address in the optimized output operator stream. <code>arg_name</code>
is the argument name of the tensor in the operator, such as "stride" in an 
"conv2d" operator.</p>
<p><code>ln_tensor_list_entry</code> and tensor list supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_tensor_list_entry *ln_tensor_list_entry_create(const char *arg_name, const char *name)</code></strong></p>
<p>Create a tensor list entry.</p>
</li>
<li>
<p><strong><code>void ln_tensor_list_entry_free(ln_tensor_list_entry *entry)</code></strong></p>
<p>Free a tensor list entry.</p>
</li>
<li>
<p><strong><code>ln_list *ln_tensor_list_append(ln_list *list, const char *arg_name, const char *name)</code></strong></p>
</li>
</ul>
<p>Append to a tensor list with an entry that has <code>arg_name</code> and <code>name</code>.</p>
<ul>
<li>
<p><strong><code>void ln_tensor_list_free(ln_list *list)</code></strong></p>
<p>Free a tensor list as well as its entries.</p>
</li>
<li>
<p><strong><code>ln_list *ln_tensor_list_copy(ln_list *list)</code></strong></p>
<p>Copy a tensor list. Entries are newly created for the new list.</p>
</li>
<li>
<p><strong><code>char *ln_tensor_list_find_name(ln_list *list, const char *arg_name)</code></strong></p>
<p>Return the tensor list entry's name that has <code>arg_name</code> from the tensor list.</p>
</li>
<li>
<p><strong><code>ln_tensor_list_entry *ln_tensor_list_find_by_arg_name(ln_list *list, const char *arg_name)</code></strong></p>
<p>Find the tensor list entry that has <code>arg_name</code> from the tensor list.</p>
</li>
<li>
<p><strong><code>ln_tensor_list_entry *ln_tensor_list_find_by_name(ln_list *list, const char *name)</code></strong></p>
<p>Find the tensor list entry that has <code>name</code> from the tensor list.</p>
</li>
<li>
<p><strong><code>ln_tensor_entry *ln_tensor_list_find_entry(ln_list *list, ln_hash *tensor_table, const char *arg_name)</code></strong></p>
<p>Find the tensor entry from <code>tensor_table</code> that has the same name with the 
tensor list entry from <code>list</code> that has <code>arg_name</code> as its arg name.</p>
</li>
<li>
<p><strong><code>int ln_tensor_list_length(ln_list *list)</code></strong></p>
<p>Return the tensor list length.</p>
</li>
<li>
<p><strong><code>int ln_tensor_list_unique_arg_name(ln_list *list, char *buf, const char *prefix)</code></strong></p>
<p>Create an arg name that is unique in the tensor list.
The arg name is prefixed with <code>prefix</code> and subfixed with a serial number,
so that unique names will be created for a same prefix.
The arg name' length should be less than <code>LN_MAX_NAME_LEN</code>. If its length
exceeds that limit, an internal error will be emited and the program will 
abort. The arg name  will be printed in <code>buf</code>. The return value is the 
subfixed number.</p>
</li>
</ul>
<h2 id="parameter">Parameter<a class="headerlink" href="#parameter" title="Permanent link">&para;</a></h2>
<p>Like <code>ln_tensor_list_entry</code>, LightNet also uses <code>ln_param_entry</code> to represent 
parameters used in an operator's parameter list. Different from <code>ln_tensor</code>,
<code>ln_param_entry</code> is often used as the configuration for the operator, but
not the input or output of the operator in the semantic meaning, such as the
stride, padding or dilation configuration for a convolution operator.</p>
<div class="codehilite"><pre><span></span><span class="k">enum</span> <span class="n">ln_param_type</span> <span class="p">{</span>
    <span class="cm">/* NULL should always be the first type */</span>
    <span class="n">LN_PARAM_NULL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">LN_PARAM_STRING</span><span class="p">,</span>
    <span class="n">LN_PARAM_NUMBER</span><span class="p">,</span>
    <span class="n">LN_PARAM_BOOL</span><span class="p">,</span>
    <span class="n">LN_PARAM_ARRAY_STRING</span><span class="p">,</span>
    <span class="n">LN_PARAM_ARRAY_NUMBER</span><span class="p">,</span>
    <span class="n">LN_PARAM_ARRAY_BOOL</span><span class="p">,</span>
    <span class="n">LN_PARAM_INVALID</span>
    <span class="cm">/* INVALID should always be the last type */</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">ln_param_type</span> <span class="n">ln_param_type</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ln_param_entry</span> <span class="p">{</span>
    <span class="kt">char</span>          <span class="o">*</span><span class="n">arg_name</span><span class="p">;</span>           <span class="cm">/* argument name in tensor list */</span>
    <span class="n">ln_param_type</span>  <span class="n">type</span><span class="p">;</span>               <span class="cm">/* parameter type */</span>
    <span class="kt">int</span>            <span class="n">array_len</span><span class="p">;</span>          <span class="cm">/* array length if it&#39;s an array */</span>
    <span class="kt">double</span>         <span class="n">value_double</span><span class="p">;</span>       <span class="cm">/* double value, as belows... */</span>
    <span class="kt">float</span>          <span class="n">value_float</span><span class="p">;</span>
    <span class="kt">int</span>            <span class="n">value_int</span><span class="p">;</span>
    <span class="n">ln_bool</span>        <span class="n">value_bool</span><span class="p">;</span>
    <span class="kt">char</span>          <span class="o">*</span><span class="n">value_string</span><span class="p">;</span>
    <span class="kt">char</span>         <span class="o">**</span><span class="n">value_array_string</span><span class="p">;</span>
    <span class="kt">double</span>        <span class="o">*</span><span class="n">value_array_double</span><span class="p">;</span>
    <span class="kt">float</span>         <span class="o">*</span><span class="n">value_array_float</span><span class="p">;</span>
    <span class="kt">int</span>           <span class="o">*</span><span class="n">value_array_int</span><span class="p">;</span>
    <span class="n">ln_bool</span>       <span class="o">*</span><span class="n">value_array_bool</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_param_entry</span> <span class="n">ln_param_entry</span><span class="p">;</span>
</pre></div>


<p>The enum type <code>ln_param_type</code> represents the param value's data type.
There are three special case here:</p>
<ol>
<li>If the param type is <code>LN_PARAM_NULL</code>, the param entry's <code>value_...</code> fields
are ignored and the param value is treated as <code>null</code>, which could represent some
special uncommon values. </li>
<li>If the param type is <code>LN_PARAM_NUMBER</code>, the param entry's <code>value_double</code>,
<code>value_float</code>, <code>value_int</code> are set in the same time when setting the param's
value with <code>ln_param_set_satu_...</code> functions, and when the number is 
beyond the data type's representable region, the maximum or minimum value will
be set as the data type's value.</li>
<li>If the param type is <code>LN_PARAM_ARRAY_NUMBER</code>, the param entry's 
<code>value_array_double</code>, <code>value_array_float</code>, <code>value_array_int</code> are set in the same
time when setting the param's value with <code>ln_param_set_satu_...</code> functions, 
and when an array's element is beyond the data type's representable 
region, the maximum or minimum value will be set as the number array's element.</li>
</ol>
<p><code>ln_param_entry</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_param_entry *ln_param_entry_create(const char *arg_name, ln_param_type type)</code></strong></p>
<p>Create a param entry.</p>
</li>
<li>
<p><strong><code>void ln_param_entry_free(ln_param_entry *entry)</code></strong></p>
<p>Free a param entry.</p>
</li>
<li>
<p><strong><code>const char *ln_param_type_name(ln_param_type type)</code></strong></p>
<p>Return the param type's string representation.</p>
</li>
<li>
<p><strong><code>ln_param_entry *ln_param_entry_copy(const ln_param_entry *pe)</code></strong></p>
<p>Copy the param entry.</p>
</li>
<li>
<p><strong><code>void ln_param_vset(ln_param_entry *entry, va_list ap)</code></strong></p>
<p>Used to write param setting functions with variable-length parameters.</p>
</li>
<li>
<p><strong><code>void ln_param_set(ln_param_entry *entry, ...)</code></strong></p>
<p>Set the param entry's value. The argument after <code>entry</code> will be interpreted
as the appropriate data type according to <code>entry-&gt;type</code>, and set as the 
entry value.</p>
</li>
<li>
<p><strong><code>void ln_param_set_null(ln_param_entry *entry)</code></strong></p>
<p>Set the param entry's type as <code>LN_PARAM_NULL</code>.</p>
</li>
<li>
<p><strong><code>void ln_param_set_bool(ln_param_entry *entry, ln_bool bool_value)</code></strong></p>
<p>Set the param entry's bool value.</p>
</li>
<li>
<p><strong><code>void ln_param_set_string(ln_param_entry *entry, const char *string)</code></strong></p>
<p>Set the param entry's string value.</p>
</li>
<li>
<p><strong><code>void ln_param_set_satu_number(ln_param_entry *entry, double number)</code></strong></p>
<p>Set the param entry's number value. The entry's <code>value_double</code>, 
<code>value_float</code>, <code>value_int</code> fields are set in the same time.
<code>value_float</code>, <code>value_int</code> are set in a saturation manner.</p>
</li>
<li>
<p><strong><code>void ln_param_set_satu_array_number(ln_param_entry *entry, int array_len, const double *array_number)</code></strong></p>
<p>Set the param entry's number array value. The entry's <code>value_array_double</code>, 
<code>value_array_float</code>, <code>value_array_int</code> fields are set in the same time.
<code>value_array_float</code>, <code>value_array_int</code> are set in a saturation manner.</p>
</li>
<li>
<p><strong><code>void ln_param_set_satu_array_double(ln_param_entry *entry, int array_len, const double *array_number)</code></strong></p>
<p>Set the param entry's number array value. The entry's <code>value_array_double</code>, 
<code>value_array_float</code>, <code>value_array_int</code> fields are set in the same time.
<code>value_array_float</code>, <code>value_array_int</code> are set in a saturation manner.</p>
</li>
<li>
<p><strong><code>void ln_param_set_satu_array_float(ln_param_entry *entry, int array_len, const float *array_number)</code></strong></p>
<p>Set the param entry's number array value. The entry's <code>value_array_double</code>, 
<code>value_array_float</code>, <code>value_array_int</code> fields are set in the same time.
<code>value_array_int</code> is set in a saturation manner.</p>
</li>
<li>
<p><strong><code>void ln_param_set_satu_array_int(ln_param_entry *entry, int array_len, const int *array_number)</code></strong></p>
<p>Set the param entry's number array value. The entry's <code>value_array_double</code>, 
<code>value_array_float</code>, <code>value_array_int</code> fields are set in the same time.</p>
</li>
<li>
<p><strong><code>void ln_param_set_array_string(ln_param_entry *entry, int array_len, const char **array_string)</code></strong></p>
<p>Set the param entry's string array value.</p>
</li>
<li>
<p><strong><code>void ln_param_set_array_bool(ln_param_entry *entry, int array_len, const ln_bool *array_bool)</code></strong></p>
<p>Set the param entry's bool array value.</p>
</li>
</ul>
<p>The param list supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_list *ln_param_list_append_empty(ln_list *list, const char *arg_name, ln_param_type ptype)</code></strong></p>
<p>Append an empty param entry to the param list. Entry values are initialized
to zeros.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_string(ln_list *list, const char *arg_name, const char *string)</code></strong></p>
<p>Append a string param entry to the param list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_number(ln_list *list, const char *arg_name, double number)</code></strong></p>
<p>Append a number param entry to the param list. Numbers are set in a 
saturation manner.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_double(ln_list *list, const char *arg_name, double number)</code></strong></p>
<p>Append a double param entry to the param list. Numbers are set in a 
saturation manner.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_float(ln_list *list, const char *arg_name, float number)</code></strong></p>
<p>Append a float param entry to the param list. Numbers are set in a 
saturation manner.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_int(ln_list *list, const char *arg_name, int number)</code></strong></p>
<p>Append an int param entry to the param list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_bool(ln_list *list, const char *arg_name, ln_bool bool_value)</code></strong></p>
<p>Append a bool param entry to the param list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_null(ln_list *list, const char *arg_name)</code></strong></p>
<p>Append a null param entry to the param list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_array_string(ln_list *list, const char *arg_name, int array_len, const char **array_string)</code></strong></p>
<p>Append a string array param entry to the param list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_array_number(ln_list *list, const char *arg_name, int array_len, const double *array_number)</code></strong></p>
<p>Append a number array param entry to the param list. Numbers are set in a 
saturation manner.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_array_double(ln_list *list, const char *arg_name, int array_len, const double *array_number)</code></strong></p>
<p>Append a double array param entry to the param list. Numbers are set in a 
saturation manner.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_array_float(ln_list *list, const char *arg_name, int array_len, const float *array_number)</code></strong></p>
<p>Append a float array param entry to the param list. Numbers are set in a 
saturation manner.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_array_int(ln_list *list, const char *arg_name, int array_len, const int *array_int)</code></strong></p>
<p>Append an int array param entry to the param list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_array_bool(ln_list *list, const char *arg_name, int array_len, const ln_bool *array_bool)</code></strong></p>
<p>Append a bool array param entry to the param list.</p>
</li>
<li>
<p><strong><code>void ln_param_list_free(ln_list *list)</code></strong></p>
<p>Free a param list, as well as the array values (if array values are set).</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_copy(ln_list *list)</code></strong></p>
<p>Copy a param list.</p>
</li>
<li>
<p><strong><code>ln_param_entry *ln_param_list_find(ln_list *list, const char *arg_name)</code></strong></p>
<p>Find a param entry with its arg name.</p>
</li>
<li>
<p><strong><code>ln_param_entry *ln_param_list_find2(ln_list *list, const char *arg_name1, const char *arg_name2)</code></strong></p>
<p>Find a param entry with its arg name. The arg name is assembled as
<code>{arg_name1}_{arg_name2}</code>.</p>
</li>
<li>
<p><strong><code>int ln_param_list_length(ln_list *list)</code></strong></p>
<p>Return the param list's length.</p>
</li>
<li>
<p><strong><code>int ln_param_list_unique_arg_name(ln_list *list, char *buf, const char *prefix)</code></strong></p>
<p>Create an arg name that is unique in the param list.
The arg name is prefixed with <code>prefix</code> and subfixed with a serial number,
so that unique names will be created for a same prefix.
The arg name' length should be less than <code>LN_MAX_NAME_LEN</code>. If its length
exceeds that limit, an internal error will be emited and the program will 
abort. The arg name  will be printed in <code>buf</code>. The return value is the 
subfixed number.</p>
</li>
</ul>
<h2 id="operator">Operator<a class="headerlink" href="#operator" title="Permanent link">&para;</a></h2>
<p>LightNet use <code>ln_op</code> to represent an operator, which receives some input tensors
and compute the output tensors according to its parameters.
A <code>ln_op</code> has its own life cycle, as showned below.</p>
<p><img style="transform:scale(0.7)" src=../img/op_state.png></p>
<p><code>ln_op</code> has 4 states in its lift cycle: <strong>init</strong>, <strong>checked</strong>, <strong>ready</strong>, <strong>end</strong>.
After created, a <code>ln_op</code> is in the <strong>init</strong> state. It has to execute its <code>pre_run</code>
function to check the validity of its input tensors and parameters, define 
its output tensors' shape, data type and so on, register its output tensors in the
tensor table, and then enter the <strong>checked</strong> state. 
For most operators, <strong>checked</strong> state is equivalent to <strong>ready</strong> state,
while there are some operators that need to execute its <code>static_run</code> function 
first to initialize their private data. 
In the <strong>ready</strong> state, an operator can execute its <code>run</code> function over and 
over again to do its real computation work. 
Or it can execute its <code>post_run</code> function to finalize its life cycle, 
free all the private memory it allocated in its life cycle, unregister its
output tensors from the tensor table, and enter the <strong>end</strong> state, where the
LightNet <a href="#context">context</a> can safely remove this operator from the operator table and
the data flow graph.</p>
<p><code>ln_op</code> has those 4 state-transfer functions in its C struct as function
pointers, which has the same prototype <code>ln_op_func</code>:</p>
<div class="codehilite"><pre><span></span><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ln_op_func</span><span class="p">)</span> <span class="p">(</span><span class="n">ln_op_arg</span> <span class="o">*</span><span class="n">op_arg</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">ln_op_offset_func</span><span class="p">)</span> <span class="p">(</span><span class="n">ln_op_arg</span> <span class="o">*</span><span class="n">op_arg</span><span class="p">,</span> <span class="n">ln_tensor_entry</span> <span class="o">*</span><span class="n">te</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ln_op</span> <span class="p">{</span>
    <span class="n">ln_op_arg</span>          <span class="o">*</span><span class="n">op_arg</span><span class="p">;</span>
    <span class="n">ln_op_func</span>          <span class="n">pre_run</span><span class="p">;</span>
    <span class="n">ln_op_func</span>          <span class="n">static_run</span><span class="p">;</span>
    <span class="n">ln_op_func</span>          <span class="n">run</span><span class="p">;</span>
    <span class="n">ln_op_func</span>          <span class="n">post_run</span><span class="p">;</span>
    <span class="n">ln_op_offset_func</span>   <span class="n">calc_offset</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_op</span> <span class="n">ln_op</span><span class="p">;</span>
</pre></div>


<p>Besides <code>ln_op_func</code>, there is another <code>ln_op_offset_func</code> used in some 
operators that hace to determine their output tensors' data address offsets
according to their input tensors.</p>
<p>Those functions all has a <code>ln_op_arg</code> as their argument, through which they can
access and manipulate the operators' input tensors (<code>tensors_in</code>), output tensors
(<code>tensors_out</code>) and parameters (<code>params</code>). Besides, <code>ln_op_arg</code> has a <code>priv</code> 
field reserved for the operators' private data. Operators can define
a private struct in their defination C file, stores its private data in it and
assign <code>priv</code> with the private struct's pointer to pass it on and use it in
different state-transfer functions.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_op_arg</span> <span class="p">{</span>
    <span class="kt">char</span>                 <span class="o">*</span><span class="n">name</span><span class="p">;</span>           <span class="cm">/* operator name */</span>
    <span class="kt">char</span>                 <span class="o">*</span><span class="n">optype</span><span class="p">;</span>         <span class="cm">/* operator type */</span>
    <span class="kt">char</span>                 <span class="o">*</span><span class="n">arch</span><span class="p">;</span>           <span class="cm">/* backend architecture to run on */</span>
    <span class="n">ln_list</span>              <span class="o">*</span><span class="n">tensors_in</span><span class="p">;</span>     <span class="cm">/* input tensors */</span>
    <span class="n">ln_list</span>              <span class="o">*</span><span class="n">tensors_out</span><span class="p">;</span>    <span class="cm">/* output tensors */</span>
    <span class="n">ln_list</span>              <span class="o">*</span><span class="n">params</span><span class="p">;</span>         <span class="cm">/* parameters */</span>
    <span class="n">ln_hash</span>              <span class="o">*</span><span class="n">tensor_table</span><span class="p">;</span>   <span class="cm">/* tensor table of the context */</span>
    <span class="kt">void</span>                 <span class="o">*</span><span class="n">priv</span><span class="p">;</span>           <span class="cm">/* for other private data storage */</span>
    <span class="k">const</span> <span class="kt">char</span>          <span class="o">**</span><span class="n">in_arg_names</span><span class="p">;</span>   <span class="cm">/* NULL terminated array, as belows */</span>
    <span class="k">const</span> <span class="kt">char</span>          <span class="o">**</span><span class="n">out_arg_names</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span>          <span class="o">**</span><span class="n">param_arg_names</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">ln_param_type</span>  <span class="o">*</span><span class="n">param_ptypes</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_op_arg</span> <span class="n">ln_op_arg</span><span class="p">;</span>
</pre></div>


<p>Every operator should implement its own <code>ln_op</code> structures, which 
are resident in <code>src/op</code>, and register its structures in the architecture 
defination it runs on. </p>
<p>For example, an operator <code>foo_cpu</code> that has input tensor "src", output tensor "dst",
and string parameter "param" should have the following structure defined 
in some file like <code>src/op/ln_opimpl_foo_cpu.c</code>.</p>
<div class="codehilite"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">foo_pre_run</span><span class="p">(</span><span class="n">ln_op_arg</span> <span class="o">*</span><span class="n">op_arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* check the input and paramenter and define the output tensor shape */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">foo_run</span><span class="p">(</span><span class="n">ln_op_arg</span> <span class="o">*</span><span class="n">op_arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* do the computation */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">foo_post_run</span><span class="p">(</span><span class="n">ln_op_arg</span> <span class="o">*</span><span class="n">op_arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* do the cleanup */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">in_arg_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&quot;src&quot;</span><span class="p">,</span>
    <span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">out_arg_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&quot;dst&quot;</span><span class="p">,</span>
    <span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">param_arg_names</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">&quot;param&quot;</span><span class="p">,</span>
    <span class="nb">NULL</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">ln_param_type</span> <span class="n">param_ptypes</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">LN_PARAM_STRING</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">ln_op_arg</span> <span class="n">op_arg_foo</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">optype</span> <span class="o">=</span> <span class="s">&quot;foo_cpu&quot;</span><span class="p">,</span>
    <span class="p">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s">&quot;cpu&quot;</span><span class="p">,</span>
    <span class="p">.</span><span class="n">in_arg_names</span> <span class="o">=</span> <span class="n">in_arg_names</span><span class="p">,</span>
    <span class="p">.</span><span class="n">out_arg_names</span> <span class="o">=</span> <span class="n">out_arg_names</span><span class="p">,</span>
    <span class="p">.</span><span class="n">param_arg_names</span> <span class="o">=</span> <span class="n">param_arg_names</span><span class="p">,</span>
    <span class="p">.</span><span class="n">param_ptypes</span> <span class="o">=</span> <span class="n">param_ptypes</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* NULL functions are equivalent to empty functions */</span>
<span class="n">ln_op</span> <span class="n">ln_opimpl_foo_cpu</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">op_arg</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">op_arg_foo</span><span class="p">,</span>
    <span class="p">.</span><span class="n">pre_run</span> <span class="o">=</span> <span class="n">foo_pre_run</span><span class="p">,</span>
    <span class="p">.</span><span class="n">static_run</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="p">.</span><span class="n">run</span> <span class="o">=</span> <span class="n">foo_run</span><span class="p">,</span>
    <span class="p">.</span><span class="n">post_run</span> <span class="o">=</span> <span class="n">foo_post_run</span><span class="p">,</span>
    <span class="p">.</span><span class="n">calc_offset</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>
</pre></div>


<p>And in <code>src/arch/ln_archimpl_cpu.c</code>, the operator shoud register itself via
these code:</p>
<div class="codehilite"><pre><span></span><span class="k">extern</span> <span class="n">ln_op</span> <span class="n">ln_opimpl_foo_cpu</span><span class="p">;</span>
<span class="p">......</span>
<span class="k">static</span> <span class="n">ln_op</span> <span class="o">*</span><span class="n">ops_cpu</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
<span class="p">...</span>
<span class="o">&amp;</span><span class="n">ln_opimpl_foo_cpu</span><span class="p">,</span>
<span class="p">...</span>
<span class="p">};</span>
</pre></div>


<p>Many operators can be automatically generated and registered by 
operator descriptions, which can reduce enormous coding efforts. Those generated
operator definations are resident in <code>src/op/auto</code>. See section 
<a href="Operator-Description.html">Operator Description</a> for more details of the description
and the associated code generation tool.</p>
<p><code>ln_op</code> generally supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_op *ln_op_create_from_proto(const ln_op *op_proto, const char *name, ln_list *tensors_in, ln_list *tensors_out, ln_list *params, ln_hash *tensor_table)</code></strong></p>
<p>Create an operator from a "proto" operator <code>op_proto</code>. The newly created operator
will have the same function pointers (<code>pre_run</code>, <code>run</code>, etc) as <code>op_proto</code>, but with
its own <code>name</code>, <code>tensors_in</code>, <code>tensors_out</code>, <code>params</code>, and a <code>tensor_table</code>
pointer of the <a href="#context">context</a> passed from the caller. <code>op_proto</code> generally are found
from the global hash table <code>LN_ARCH.op_proto_table</code> with its operator type as 
the key.</p>
</li>
<li>
<p><strong><code>void ln_op_free(ln_op *op)</code></strong></p>
<p>Free an operator.</p>
</li>
<li>
<p><strong><code>void ln_op_free_lists_too(ln_op *op)</code></strong></p>
<p>Free an operator, as well as its <code>tensors_in</code>, <code>tensors_out</code> and <code>params</code>.</p>
</li>
<li>
<p><strong><code>ln_op *ln_op_create_with_names(const ln_op *op_proto, const ln_list *ops, ln_hash *tensor_table)</code></strong></p>
<p>Create an operator of the same optype as <code>op_proto</code> and create its <code>tensors_in</code>,
<code>tensors_out</code> and <code>params</code> as well,
with auto-generated unique operator name and output tensor names in the scope
of <code>ops</code>. Input tensor names are inited with empty string (""), and
parameters are inited with empty value (zeroed number or <code>NULL</code> string or
<code>NULL</code> array). 
The meta information of the operator used to create those 
stuff is found in <code>ln_op_arg</code>'s <code>in_arg_names</code>, <code>out_arg_names</code>, 
<code>param_arg_names</code>, <code>param_ptypes</code>, etc.
This function is mainly used in optimization pass where LightNet will 
generate optimized new operators to replace old ones.</p>
</li>
<li>
<p><strong><code>ln_op *ln_op_create_with_opname(const ln_op *op_proto, ln_hash *tensor_table)</code></strong></p>
<p>Create an operator of the same optype as <code>op_proto</code> with auto-generated 
unique operator name in the scope of <code>ops</code>.</p>
</li>
<li>
<p><strong><code>ln_op *ln_op_copy(const ln_op *op)</code></strong></p>
<p>Copy an operator.</p>
</li>
<li>
<p><strong><code>ln_op *ln_op_copy_to_optype(ln_hash *op_proto_table, const ln_op *op, const char *new_optype)</code></strong></p>
<p>Copy an operator's input/output tensors and parameters to a newly created
operator of a new operator type <code>new_optype</code>. Generally used in the simple 
replacement from one optype to another in optimization pass, such as
replacing <code>conv</code> with <code>conv_cuda</code>.</p>
</li>
<li>
<p><strong><code>ln_tensor_entry *ln_op_find_tensor_entry(const ln_op *op, const char *arg_name)</code></strong></p>
<p>Find an operator's input or output tensor entry with the entry's <code>arg_name</code>.</p>
</li>
<li>
<p><strong><code>ln_tensor_list_entry *ln_op_find_tensor_list_entry(const ln_op *op, const char *arg_name)</code></strong></p>
<p>Find an operator's input or output tensor list entry with the entry's <code>arg_name</code>.</p>
</li>
</ul>
<p>The are both an operator table and an operator list existing in a LightNet <a href="#context">context</a>.
While the former is the <em>single spot of truth</em> of all operators, the latter retains
a linear form of the operators, which contains the execution order of the operators.</p>
<p>The operator list supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_list *ln_op_list_create_from_array(ln_op **op_array)</code></strong></p>
<p>Create an operator list from an <code>NULL</code> terminated operator array.</p>
</li>
<li>
<p><strong><code>void ln_op_list_free(ln_list *ops)</code></strong></p>
<p>Free an operator list.</p>
</li>
<li>
<p><strong><code>void ln_op_list_free_lists_too(ln_list *ops)</code></strong></p>
<p>Free an operator list, as well as the operators' tensor lists and
parameter list.</p>
</li>
<li>
<p><strong><code>ln_op *ln_op_list_find_by_optype(ln_list *ops, const char *optype)</code></strong></p>
<p>Find the first operator from an operator list that has <code>optype</code> as its
operator type.</p>
</li>
<li>
<p><strong><code>ln_op *ln_op_array_find_by_optype(ln_op *ops[], const char *optype)</code></strong></p>
<p>Find the first operator from an <code>NULL</code> terminated operator array that
has <code>optype</code> as its operator type.</p>
</li>
<li>
<p><strong><code>ln_op *ln_op_list_find_by_name(ln_list *ops, const char *name)</code></strong></p>
<p>Find the first operator from an operator list that has <code>name</code> as its
operator name.</p>
</li>
<li>
<p><strong><code>void ln_op_list_do_pre_run(ln_list *ops)</code></strong></p>
<p>Execute the <code>pre_run</code> functions of the operators in <code>ops</code> in order.</p>
</li>
<li>
<p><strong><code>void ln_op_list_do_static_run(ln_list *ops)</code></strong></p>
<p>Execute the <code>static_run</code> functions of the operators in <code>ops</code> in order.</p>
</li>
<li>
<p><strong><code>void ln_op_list_do_run(ln_list *ops)</code></strong></p>
<p>Execute the <code>run</code> functions of the operators in <code>ops</code> in order.</p>
</li>
<li>
<p><strong><code>void ln_op_list_do_post_run(ln_list *ops)</code></strong></p>
<p>Execute the <code>post_run</code> functions of the operators in <code>ops</code> in order.</p>
</li>
<li>
<p><strong><code>int ln_op_list_unique_name(const ln_list *ops, char *buf, const char *prefix)</code></strong></p>
<p>Create and print an unique operator name in the scope of <code>ops</code>
with <code>prefix</code> in <code>buf</code>.
The created name is prefixed with <code>prefix</code> and subfixed with a serial number,
which is the return value.</p>
</li>
</ul>
<p>The operator table supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_hash *ln_op_table_create(void)</code></strong></p>
<p>Create an empty operator table.</p>
</li>
<li>
<p><strong><code>int ln_op_table_insert(ln_hash *table, ln_op *op)</code></strong></p>
<p>Insert an operator to the table.</p>
</li>
<li>
<p><strong><code>int ln_op_table_remove(ln_hash *table, const char *name)</code></strong></p>
<p>Remove an operator from the table. The operator table will free the operator,
its tensor lists and parameter list when removing it from the table.</p>
</li>
<li>
<p><strong><code>ln_op *ln_op_table_find(ln_hash *table, const char *name)</code></strong></p>
<p>Find an operator from the table with its name.</p>
</li>
<li>
<p><strong><code>void ln_op_table_free(ln_hash *table)</code></strong></p>
<p>Free an operator table, as well as its operators.</p>
</li>
<li>
<p><strong><code>void ln_op_table_vset_param(ln_hash *table, const char *opname, const char *pname, va_list ap)</code></strong></p>
<p>Set an operator's parameter in the operator table.
Used in variable-length functions.</p>
</li>
<li>
<p><strong><code>void ln_op_table_set_param(ln_hash *table, const char *opname, const char *pname, ...)</code></strong></p>
<p>Set an operator's parameter with operator name <code>opname</code> in the operator table
and parameter argument name <code>pname</code> in the parameter list.
The function argument after <code>pname</code> should be a parameter value with an 
appropriate data type consistent with the according parameter.</p>
</li>
</ul>
<p>There are also a bunch of macros designated for the validity checking of tensors
and parameters in <code>pre_run</code> function, which can generate unified formatted message
when the check fails.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Those convinent macros should <strong>only</strong> used in a <code>pre_run</code> function 
because of the function arguments they required. 
Normally we shouldn't use those kind of error handling routines in
other state-transfer functions, where errors should be considered
as bugs.
If there is more error handling work, please write the code yourself
instead of using those macros.</p>
</div>
<ul>
<li>
<p><strong><code>ln_opck(level, condition, msg_fmt, varg...)</code></strong></p>
<p>If <code>condition</code> not satisfied, emit message defined by printf-liked arguments 
<code>msg_fmt</code>and <code>varg...</code>, according to message level <code>level</code> (an enum defined in 
<code>ln_msg.h</code>).</p>
</li>
<li>
<p><strong><code>ln_opck_satisfy_msg(condition, msg_fmt, varg...)</code></strong></p>
<p>Emit error message if <code>condition</code> not satisfied and exit.</p>
</li>
<li>
<p><strong><code>ln_opck_satisfy(condition)</code></strong></p>
<p>Emit error message if <code>condition</code> not satisfied and exit.</p>
</li>
<li>
<p><strong><code>ln_opck_param_exist(entry, arg_name)</code></strong></p>
<p>Check if a param entry exists. <code>entry</code> should be returned by
<code>ln_param_list_find(op_arg-&gt;params, arg_name)</code>.</p>
</li>
<li>
<p><strong><code>ln_opck_param_type(entry, param_type)</code></strong></p>
<p>Check if a param entry's type is equal to <code>param_type</code>.
<code>param_type</code> is an enum <code>of ln_param_type</code> defined in <code>ln_param.h</code>.
<code>entry</code> should have been checked with <code>ln_opck_param_exist</code>.</p>
</li>
</ul>
<p>The following macros check if a number param entry's value is equal to (<code>eq</code>), 
greater than (<code>gt</code>), greater than or equal to (<code>ge</code>), less than (<code>lt</code>),
less than or equal to (<code>le</code>), or not equal to (<code>ne</code>) the number <code>expect</code>.
<code>entry</code> should have been checked with <code>ln_opck_param_exist</code>.</p>
<ul>
<li><strong><code>ln_opck_param_int_eq(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_int_gt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_int_ge(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_int_lt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_int_le(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_int_ne(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_float_eq(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_float_gt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_float_ge(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_float_lt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_float_le(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_float_ne(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_double_eq(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_double_gt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_double_ge(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_double_lt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_double_le(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_double_ne(entry, expect)</code></strong></li>
</ul>
<p>The following macros check if an array param entry's value's length is
equal to (<code>eq</code>), greater than (<code>gt</code>), greater than or equal to (<code>ge</code>), 
less than (<code>lt</code>), less than or equal to (<code>le</code>), or not equal to (<code>ne</code>)
the length <code>expect_len</code>. 
<code>entry</code> should have been checked with <code>ln_opck_param_exist</code>.</p>
<ul>
<li><strong><code>ln_opck_param_array_len_eq(entry, expect_len)</code></strong></li>
<li><strong><code>ln_opck_param_array_len_gt(entry, expect_len)</code></strong></li>
<li><strong><code>ln_opck_param_array_len_ge(entry, expect_len)</code></strong></li>
<li><strong><code>ln_opck_param_array_len_lt(entry, expect_len)</code></strong></li>
<li><strong><code>ln_opck_param_array_len_le(entry, expect_len)</code></strong></li>
</ul>
<p>The following macros check if a number array param entry's values are all
equal to (<code>eq</code>), greater than (<code>gt</code>), greater than or equal to (<code>ge</code>), 
less than (<code>lt</code>), less than or equal to (<code>le</code>), or not equal to (<code>ne</code>) 
the number <code>expect</code>.
<code>entry</code> should have been checked with <code>ln_opck_param_exist</code>.</p>
<ul>
<li><strong><code>ln_opck_param_array_int_eq(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_int_gt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_int_ge(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_int_lt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_int_le(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_int_ne(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_float_eq(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_float_gt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_float_ge(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_float_lt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_float_le(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_float_ne(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_double_eq(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_double_gt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_double_ge(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_double_lt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_double_le(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_double_ne(entry, expect)</code></strong></li>
</ul>
<p>The following macros check if the length of the parameter list (<code>list_len</code>)
is equal to (<code>eq</code>), greater than (<code>gt</code>), greater than or equal to (<code>ge</code>), 
less than (<code>lt</code>), less than or equal to (<code>le</code>), or not equal to (<code>ne</code>) 
the length <code>expect_len</code>.
<code>list_len</code> should be returned by <code>ln_param_list_length(op_arg-&gt;params)</code>.</p>
<ul>
<li><strong><code>ln_opck_params_len_eq(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_params_len_gt(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_params_len_ge(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_params_len_lt(list_len, expect_len)</code></strong></li>
<li>
<p><strong><code>ln_opck_params_len_le(list_len, expect_len)</code></strong></p>
</li>
<li>
<p><strong><code>ln_opck_tensor_in_exist(entry, arg_name)</code></strong></p>
<p>Check if an input tensor list entry exists. <code>entry</code> should be returned by
<code>ln_tensor_list_find_by_arg_name(op_arg-&gt;tensors_in, arg_name)</code>.</p>
</li>
</ul>
<p>The following macros check if the length of the input tensor list (<code>list_len</code>)
is equal to (<code>eq</code>), greater than (<code>gt</code>), greater than or equal to (<code>ge</code>), 
less than (<code>lt</code>), less than or equal to (<code>le</code>), or not equal to (<code>ne</code>) 
the length <code>expect_len</code>.
<code>list_len</code> should be returned by <code>ln_tensor_list_length(op_arg-&gt;tensors_in)</code>.</p>
<ul>
<li><strong><code>ln_opck_tensors_in_len_eq(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_tensors_in_len_gt(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_tensors_in_len_ge(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_tensors_in_len_lt(list_len, expect_len)</code></strong></li>
<li>
<p><strong><code>ln_opck_tensors_in_len_le(list_len, expect_len)</code></strong></p>
</li>
<li>
<p><strong><code>ln_opck_tensor_out_exist(entry, arg_name)</code></strong></p>
<p>Check if an output tensor list entry exists. <code>entry</code> should be returned by
<code>ln_tensor_list_find_by_arg_name(op_arg-&gt;tensors_out, arg_name)</code>.</p>
</li>
</ul>
<p>The following macros check if the length of the output tensor list (<code>list_len</code>)
is equal to (<code>eq</code>), greater than (<code>gt</code>), greater than or equal to (<code>ge</code>), 
less than (<code>lt</code>), less than or equal to (<code>le</code>), or not equal to (<code>ne</code>) 
the length <code>expect_len</code>.
<code>list_len</code> should be returned by <code>ln_tensor_list_length(op_arg-&gt;tensors_out)</code>.</p>
<ul>
<li><strong><code>ln_opck_tensors_out_len_eq(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_tensors_out_len_gt(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_tensors_out_len_ge(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_tensors_out_len_lt(list_len, expect_len)</code></strong></li>
<li>
<p><strong><code>ln_opck_tensors_out_len_le(list_len, expect_len)</code></strong></p>
</li>
<li>
<p><strong><code>ln_opck_tensor_not_defined(entry, entry_name)</code></strong></p>
<p>Check if the tensor entry <code>entry</code> has <em>not</em> been defined by another
operator so far. "defined" means an operator has created the tensor
and inserted the tensor entry in the tensor table.
<code>entry</code> should be returned by
<code>ln_tensor_table_find(op_arg-&gt;tensor_table, entry_name)</code>, where <code>entry_name</code>
is the <code>ln_tensor_entry</code>'s name to be looked up.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_defined(entry, entry_name)</code></strong></p>
<p>Check if the tensor entry <code>entry</code> has been defined by another
operator so far.
<code>entry</code> should be returned by
<code>ln_tensor_table_find(op_arg-&gt;tensor_table, entry_name)</code>, where <code>entry_name</code>
is the <code>ln_tensor_entry</code>'s name to be looked up.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_ndim(entry, expect_ndim)</code></strong></p>
<p>Check if the tensor in <code>entry</code> has the number of dimensions equal to
<code>expect_ndim</code>.
<code>entry</code> should have been checked with <code>ln_opck_tensor_defined</code>.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_len(entry, expect_len)</code></strong></p>
<p>Check if the tensor in <code>entry</code> has the number of elements equal to
<code>expect_len</code>.
<code>entry</code> should have been checked with <code>ln_opck_tensor_defined</code>.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_issameshape(entry1, entry2)</code></strong></p>
<p>Check if the tensor in <code>entry1</code> has the same shape with the tensor in
<code>entry2</code>.
Both <code>entry1</code> and <code>entry2</code> should have been checked with <code>ln_opck_tensor_defined</code>.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_issametype(entry1, entry2)</code></strong></p>
<p>Check if the tensor in <code>entry1</code> has the same data type with the tensor in
<code>entry2</code>.
Both <code>entry1</code> and <code>entry2</code> should have been checked with <code>ln_opck_tensor_defined</code>.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_isstatic(entry)</code></strong></p>
<p>Check if the tensor in <code>entry</code> is static.
<code>entry</code> should have been checked with <code>ln_opck_tensor_defined</code>.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_isnotstatic(entry)</code></strong></p>
<p>Check if the tensor in <code>entry</code> is <em>not</em> static.
<code>entry</code> should have been checked with <code>ln_opck_tensor_defined</code>.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_mtype_eq(entry, mem_type)</code></strong></p>
<p>Check if the tensor in <code>entry</code> has the memory type equals to <code>mem_type</code>.
<code>entry</code> should have been checked with <code>ln_opck_tensor_defined</code>.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_dtype_eq(entry, data_type)</code></strong></p>
<p>Check if the tensor in <code>entry</code> has the data type equals to <code>data_type</code>.
<code>entry</code> should have been checked with <code>ln_opck_tensor_defined</code>.</p>
</li>
</ul>
<h2 id="data-flow-graph">Data Flow Graph<a class="headerlink" href="#data-flow-graph" title="Permanent link">&para;</a></h2>
<p>LightNet uses Data Flow Graph (<code>ln_dfg</code>) to represent data flows among operators,
as known as computing graph.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_dfg</span> <span class="p">{</span>
    <span class="n">ln_graph</span> <span class="o">*</span><span class="n">graph</span><span class="p">;</span>
    <span class="n">ln_hash</span>  <span class="o">*</span><span class="n">node_table</span><span class="p">;</span>
    <span class="n">ln_list</span>  <span class="o">*</span><span class="n">dangling_ins</span><span class="p">;</span>
    <span class="n">ln_list</span>  <span class="o">*</span><span class="n">dangling_outs</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_dfg</span> <span class="n">ln_dfg</span><span class="p">;</span>
</pre></div>


<p><code>ln_dfg</code> has a <code>graph</code> as its core data structure, with operators as nodes and
tensor names as edges. Besides, it has a <code>node_table</code> to manage all the graph nodes
in a hash table, keyed by operator names, a <code>dangling_outs</code> list to manage all 
the reaching out dangling edge nodes, and a <code>dangling_ins</code> list to manage all 
the reaching in dangling edge nodes.</p>
<p><code>ln_dfg</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_dfg *ln_dfg_create(void)</code></strong></p>
<p>Create an empty data flow graph.</p>
</li>
<li>
<p><strong><code>void ln_dfg_free(ln_dfg *dfg)</code></strong></p>
<p>Free a data flow graph, as well as its <code>graph</code>, <code>node_table</code>, <code>dangling_ins</code>, 
<code>dangling_outs</code>.</p>
</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The operator pointers held by graph nodes are owned by <code>op_table</code> of the 
<a href="#context">context</a>. So freeing <code>graph</code> and <code>node_table</code> doesn't actually free the
underlying operators. (TODO: May be the graph nodes holding operator names is 
well enough?)</p>
</div>
<ul>
<li>
<p><strong><code>void ln_dfg_link(ln_dfg *dfg, ln_op *op1, ln_op *op2, const char *tname)</code></strong></p>
<p>Link the node holding <code>op1</code> to the node holding <code>op2</code>, with tensor name <code>tname</code>
as the edge.</p>
</li>
<li>
<p><strong><code>void ln_dfg_unlink(ln_dfg *dfg, ln_op *op1, ln_op *op2, const char *tname)</code></strong></p>
<p>Unlink the node holding <code>op1</code> to the node holding <code>op2</code>, with tensor name <code>tname</code>
as the edge. If <code>tname</code> is not the output tensor of <code>op1</code> or not the input
tensor of <code>op2</code>, this function does nothing.</p>
</li>
<li>
<p><strong><code>void ln_dfg_add(ln_dfg *dfg, ln_op *op)</code></strong></p>
<p>Add <code>op</code> to the <code>dfg</code>. The new node automatically gets linked with its output
tensors to nodes that take them as input tensors (if any), and gets linked 
with its input tensors from nodes that take them as output tensors (if any),
and removes/adds related entries in the <code>dfg</code>'s <code>dangling_outs</code> and
<code>dangling_ins</code>.</p>
</li>
<li>
<p><strong><code>void ln_dfg_remove(ln_dfg *dfg, ln_op *op)</code></strong></p>
<p>Remove <code>op</code> to the <code>dfg</code>. The node automatically gets unlinked with its output
tensors to nodes that take them as input tensors (if any), and gets unlinked 
with its input tensors from nodes that take them as output tensors (if any),
and removes/adds related entries in the <code>dfg</code>'s <code>dangling_outs</code> and
<code>dangling_ins</code>.</p>
</li>
<li>
<p><strong><code>ln_op *ln_dfg_next(const ln_dfg *dfg, const ln_op *op, const char *tname)</code></strong></p>
<p>(Deprecated)
Return the operator that has <code>tname</code> as its input tensor's name, which is also
operator <code>op</code>'s output tensor.</p>
</li>
<li>
<p><strong><code>ln_list *ln_dfg_nexts(const ln_dfg *dfg, const ln_op *op, const char *tname)</code></strong></p>
<p>Return all operators that have <code>tname</code> as their input tensor's name, which is also
operator <code>op</code>'s output tensor.</p>
</li>
<li>
<p><strong><code>ln_op *ln_dfg_prev(const ln_dfg *dfg, const ln_op *op, const char *tname)</code></strong></p>
<p>Return the operator that has <code>tname</code> as its output tensor's name, which is also
operator <code>op</code>'s input tensor.</p>
</li>
<li>
<p><strong><code>int ln_dfg_check(const ln_dfg *dfg)</code></strong></p>
<p>Check the correctness of a data flow graph <code>dfg</code>. It emits an internal error if
any operator's input tensor is not given by another operator.</p>
</li>
<li>
<p><strong><code>void ln_dfg_fprint(FILE *fp, const ln_dfg *dfg)</code></strong></p>
<p>Print the <code>dfg</code> to file stream <code>fp</code>.</p>
</li>
<li>
<p><strong><code>void ln_dfg_print(const ln_dfg *dfg)</code></strong></p>
<p>Print the <code>dfg</code> to stdout.</p>
</li>
</ul>
<h2 id="context">Context<a class="headerlink" href="#context" title="Permanent link">&para;</a></h2>
<p>LightNet needs a data structure to manage all the resources dedicated to the
optimization and execution for a specific neural network model, such as its
tensor table, operator table and the data flow graph. <code>ln_context</code> is such a data structure.`</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_context</span> <span class="p">{</span>
    <span class="n">ln_hash</span> <span class="o">*</span><span class="n">tensor_table</span><span class="p">;</span>                 <span class="cm">/* the tensor table */</span>
    <span class="n">ln_hash</span> <span class="o">*</span><span class="n">op_table</span><span class="p">;</span>                     <span class="cm">/* the operator table */</span>
    <span class="n">ln_dfg</span>  <span class="o">*</span><span class="n">dfg</span><span class="p">;</span>                          <span class="cm">/* the data flow graph */</span>
    <span class="n">ln_list</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>                          <span class="cm">/* the operator list */</span>
    <span class="kt">void</span>    <span class="o">*</span><span class="n">mem_starts</span><span class="p">[</span><span class="n">LN_MEM_TYPE_SIZE</span><span class="p">];</span> <span class="cm">/* the memory start addresses */</span>
    <span class="kt">size_t</span>   <span class="n">mem_sizes</span><span class="p">[</span><span class="n">LN_MEM_TYPE_SIZE</span><span class="p">];</span>  <span class="cm">/* the memory sizes */</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_context</span> <span class="n">ln_context</span><span class="p">;</span>
</pre></div>


<p><code>ln_context</code> acts the role as the <strong>single point of truth</strong> of other data 
structures of a specific NN model.</p>
<ol>
<li>
<p>It has a <code>tensor_table</code> to manage all the tensors used by the model.
Every <a href="#operator">operator</a> has to create and insert its output tensors in
the tensor table in its <code>pre_run</code> function, and remove the tensors in its
<code>post_run</code> function.</p>
</li>
<li>
<p>It has an <code>op_table</code> to manage all the operators used by the model.
The context has to create and insert operators to <code>op_table</code>, and remove them
from <code>op_table</code> when initializing/finalizing the context, and when optimizing 
the model.</p>
</li>
<li>
<p>It has a <code>dfg</code> to represent the <a href="#data-flow-graph">data flow graph</a> of the model,
which is used to reserve the topological infomation used in model optimization.</p>
</li>
<li>
<p>It has a <code>ops</code> to represent a list of the operators,
which is used to reserve the linear form the operators used in model optimization.</p>
</li>
<li>
<p>It has a <code>mem_starts</code> to record the memory start addresses of all kinds of
memory types (main memory, GPU memory, etc.). It is used in the execution phase
of the model.</p>
</li>
<li>
<p>It has a <code>mem_sizes</code> to record the memory sizes of all kinds of memory types
needed by the model. It is determined in the memory planning phase in model 
optimization. It is used in the execution phase as the allocation size of
different memory types.</p>
</li>
</ol>
<p><code>ln_context</code> has the following operations to complete its main functions.</p>
<ul>
<li>
<p><strong><code>ln_context *ln_context_create(void)</code></strong></p>
<p>Create a context, and zero-initialize its fields.</p>
</li>
<li>
<p><strong><code>void ln_context_free(ln_context *ctx)</code></strong></p>
<p>Free a context, as well as its <code>tensor_table</code> (as well as all its tensors),
<code>op_table</code> (as well as all the operators), <code>dfg</code>, and <code>ops</code>.</p>
</li>
<li>
<p><strong><code>void ln_context_init(ln_context *ctx, const char *source)</code></strong></p>
<p>Initialize a context from a model source JSON file. 
Create all the operators and tensors and build the data flow graph.
See <a href="Intermediate-Representation.html">Intermediate Representation</a>
for details of the <code>source</code>'s format.</p>
</li>
<li>
<p><strong><code>void ln_context_compile(ln_context *ctx, const char *target)</code></strong></p>
<p>Execute speed and memory optimization on <code>target</code> platform,
such as "cpu", "tensorrt", etc.</p>
</li>
<li>
<p><strong><code>void ln_context_print(const ln_context *ctx, const char *outfile)</code></strong></p>
<p>Print the current linear form of operators in a JSON file named <code>outfile</code>.
See <a href="Intermediate-Representation.html">Intermediate Representation</a>
for details of the outfile format.</p>
</li>
<li>
<p><strong><code>void ln_context_load(ln_context *ctx, const char *datafile)</code></strong></p>
<p>Allocate the memory of different kinds of memory types required by the model.
Load data from a <code>datafile</code> to the memory address of tensors' data.
Use <code>tools/genwts.pl -h</code> for the format of the <code>datafile</code>.</p>
</li>
<li>
<p><strong><code>void ln_context_set_data(ln_context *ctx, const char *tname, const void *data)</code></strong></p>
<p>Copy the value of tensor named <code>tname</code> from <code>data</code>.</p>
</li>
<li>
<p><strong><code>void *ln_context_get_data(ln_context *ctx, const char *tname, void *data)</code></strong></p>
<p>Copy the value of tensor named <code>tname</code> to <code>data</code>.</p>
</li>
<li>
<p><strong><code>size_t ln_context_data_size(ln_context *ctx, const char *tname)</code></strong></p>
<p>Return the size in bytes of the data of tensor named <code>tname</code>.</p>
</li>
<li>
<p><strong><code>void ln_context_set_param(ln_context *ctx, const char *opname, const char *pname, ...)</code></strong></p>
<p>Set the parameter value of parameter named <code>pname</code> of operator named <code>opname</code>.
Arguments after <code>pname</code> should conform to the data type of the parameter.</p>
</li>
<li>
<p><strong><code>void ln_context_run(const ln_context *ctx)</code></strong></p>
<p>Run the <code>run</code> function of all operators in the order of <code>ctx-&gt;ops</code>.</p>
</li>
<li>
<p><strong><code>void ln_context_unload(ln_context *ctx)</code></strong></p>
<p>Free the memory allocated by <code>ln_context_load</code>.</p>
</li>
<li>
<p><strong><code>void ln_context_cleanup(ln_context *ctx)</code></strong></p>
<p>Cleanup a context. Release all the resources acquired by <code>ln_context_init</code>.</p>
</li>
</ul>
<p>Besides, <code>ln_context</code> has the following operations to support the above 
main functions. Some are used in <code>ln_pass</code> module for optimization passes.</p>
<ul>
<li>
<p><strong><code>void ln_context_init_ops(ln_context *ctx)</code></strong></p>
<p>Initialize the operators, insert them to the operator table, 
run their <code>pre_run</code>s and construct the data flow graph.</p>
</li>
<li>
<p><strong><code>void ln_context_cleanup_ops(ln_context *ctx)</code></strong></p>
<p>Finalize the operators, do the opposite things that <code>ln_context_init_ops</code> 
does.</p>
</li>
<li>
<p><strong><code>void ln_context_replace_ops(ln_context *ctx, ln_list **position, size_t len, ln_list *new_ops)</code></strong></p>
<p>Replace the operators in <code>ctx-&gt;ops</code> at <code>position</code> with <code>ops</code> of length <code>len</code>.
And automatically update the data flow graph <code>ctx-&gt;dfg</code>.</p>
</li>
<li>
<p><strong><code>void ln_context_remove_op(ln_context *ctx, ln_list **position)</code></strong></p>
<p>Remove the operator at <code>postion</code> in <code>ctx-&gt;ops</code>.</p>
</li>
<li>
<p><strong><code>void ln_context_add_op(ln_context *ctx, ln_list **position, ln_op *new_op)</code></strong></p>
<p>Add <code>new_op</code> to <code>postion</code> in <code>ctx-&gt;ops</code>.</p>
</li>
<li>
<p><strong><code>void ln_context_subgraph(ln_context *ctx, ln_list *old_ops, ln_list *new_ops)</code></strong></p>
<p>Substitute <code>old_ops</code> with <code>new_ops</code> in <code>ctx</code>.</p>
</li>
<li>
<p><strong><code>int ln_context_check(const ln_context *ctx)</code></strong></p>
<p>Check the context's validity, which should be checked after every alternation
of the operators.</p>
</li>
<li>
<p><strong><code>void ln_context_alloc_mem(ln_context *ctx)</code></strong></p>
<p>Allocate the memory that the context's tensors use. This must be called after
the memory has been planned.</p>
</li>
<li>
<p><strong><code>void ln_context_dealloc_mem(ln_context *ctx)</code></strong></p>
<p>Deallocate the memory allocated by <code>ln_context_alloc_mem()</code>.</p>
</li>
</ul>
<h2 id="architecture">Architecture<a class="headerlink" href="#architecture" title="Permanent link">&para;</a></h2>
<p>The backend information of a specific hardware or software is stored in the
architecture struct, <code>ln_arch</code>.</p>
<div class="codehilite"><pre><span></span><span class="k">typedef</span> <span class="n">ln_list</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">ln_expander_func</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="n">ln_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">ln_op</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
                                      <span class="kt">int</span> <span class="o">*</span><span class="n">match</span><span class="p">);</span>
<span class="k">typedef</span> <span class="n">ln_list</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">ln_combiner_func</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="n">ln_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">ln_list</span> <span class="o">*</span><span class="n">win_ops</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">win_size</span><span class="p">,</span>
                                      <span class="kt">int</span> <span class="o">*</span><span class="n">match</span><span class="p">);</span>
<span class="k">typedef</span> <span class="n">ln_list</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">ln_subgraph_func</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="n">ln_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ln_list</span> <span class="o">**</span><span class="n">old_ops</span><span class="p">);</span>
<span class="k">typedef</span> <span class="n">ln_list</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">ln_schedule_func</span><span class="p">)</span> <span class="p">(</span><span class="k">const</span> <span class="n">ln_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ln_arch</span> <span class="p">{</span>
    <span class="kt">void</span>              <span class="p">(</span><span class="o">*</span><span class="n">init_func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">**</span><span class="n">priv_p</span><span class="p">);</span> <span class="cm">/* pointer to priv */</span>
    <span class="kt">void</span>              <span class="p">(</span><span class="o">*</span><span class="n">cleanup_func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">**</span><span class="n">priv_p</span><span class="p">);</span>
    <span class="kt">void</span>               <span class="o">*</span><span class="n">priv</span><span class="p">;</span>
    <span class="n">ln_op</span>             <span class="o">**</span><span class="n">reg_ops</span><span class="p">;</span>       <span class="cm">/* NULL terminated */</span>
    <span class="n">ln_expander_func</span>   <span class="o">*</span><span class="n">ep_funcs</span><span class="p">;</span>      <span class="cm">/* NULL terminated */</span>
    <span class="n">ln_combiner_func</span>   <span class="o">*</span><span class="n">cb_funcs</span><span class="p">;</span>      <span class="cm">/* NULL terminated */</span>
    <span class="n">ln_subgraph_func</span>   <span class="o">*</span><span class="n">sg_funcs</span><span class="p">;</span>      <span class="cm">/* NULL terminated */</span>
    <span class="n">ln_schedule_func</span>   <span class="o">*</span><span class="n">sd_funcs</span><span class="p">;</span>      <span class="cm">/* NULL terminated */</span>
    <span class="kt">char</span>               <span class="o">*</span><span class="n">arch_name</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_arch</span> <span class="n">ln_arch</span><span class="p">;</span>
</pre></div>


<p>Every architecture has its own registered operators in <code>reg_ops</code>, 
which are the operators that can run on this platform and has the same
<code>arch</code> field as that arch's <code>arch_name</code>.</p>
<p><code>ln_arch</code> also contains the optimizer functions that the platform can perform
on the operators in one context, which should be provided by the <code>ln_arch</code>'s 
author. There are four kinds of optimizer functions, each of which has an array
of <code>NULL</code> terminated function pointers, which are applied to the context in order
when LightNet is compiling the NN model. The optimizer functions includes:</p>
<ul>
<li>
<p><strong><code>ln_list *(*ln_expander_func) (const ln_context *ctx, const ln_op *op, int *match)</code></strong></p>
<p>Expand operator <code>op</code> to the operators in the returned list. 
The returned list may be <code>NULL</code>, in which case the original <code>op</code> is removed.
If <code>op</code> cannot be expanded by this function, <code>*match</code> should be assigned with
0, else it should be assigned with 1.</p>
</li>
<li>
<p><strong><code>ln_list *(*ln_combiner_func) (const ln_context *ctx, const ln_list *win_ops, size_t win_size, int *match)</code></strong></p>
<p>Combine operators in list <code>win_ops</code> of length <code>win_size</code> to another list of
operators in the returned list.
The returned list may be <code>NULL</code>, in which case the original <code>win_ops</code> is removed.
If <code>win_ops</code> cannot be combined by this function, <code>*match</code> should be assigned with
0, else it should be assigned with 1.</p>
</li>
<li>
<p>(experiment) <strong><code>ln_list *(*ln_subgraph_func) (const ln_context *ctx, ln_list **old_ops)</code></strong></p>
<p>Substitute operators in <code>old_ops</code> to the operators in the returned list.</p>
</li>
<li>
<p>(experiment) <strong><code>ln_list *(*ln_schedule_func) (const ln_context *ctx)</code></strong></p>
<p>Schedule the order of operators in <code>ctx-&gt;ops</code>.</p>
</li>
</ul>
<p>An expander function can transform <em>one</em> operator <code>op</code> to one or several other
operators in its returned operator list. An combiner function can transform
<em>several</em> operators to one or several other operators in its returned operator 
list. Those two function may seems overlayed in functionalities, but they're 
designed to implement a well-known "peephole optimizer" learned from classic
compiler techniques, that first expands individual abstract instructions 
to platform-related low-level instructions, then combines adjacent low-level
instructions to fewer instructions which can fulfill complex tasks in less time.</p>
<p>The expander functions and combiner functions are all operations performed on the
linear form of operators. Although they can make optimization decisions according
to the information gived by data flow graph though <code>ctx-&gt;dfg</code>, the optimizations
themselves must be made on operators adjacent in <code>ctx-&gt;ops</code>.</p>
<p>The subgrapher function and scheduler function are experiment features that are 
not stable now.</p>
<p>Besides, there is an <code>init_func</code> and <code>cleanup_func</code> associated with a private
data pointer <code>priv</code> in a <code>ln_arch</code> structure, which are used for the 
initialization and finalization of the architecture. The <code>priv</code> data pointer can
be used for any data structure that the architecture may use for its private data
during its runtime.</p>
<p>Every architecture must define its own <code>ln_arch</code> structure, which are resident
in <code>src/arch</code>, and register itself in <code>src/ln_arch.c</code>. </p>
<p>Some optimizer functions can be automatically generated by
optimizer descriptions. Those generated optimizer functions are resident in
<code>src/arch/auto</code>. See <a href="Optimizer-Description.html">Optimizer Description</a>
for more details.</p>
<p>LightNet's architectures have a global access point <code>LN_ARCH</code>, 
of type <code>struct ln_arch_info</code>:</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_arch_info</span> <span class="p">{</span>
    <span class="n">ln_hash</span>  <span class="o">*</span><span class="n">arch_table</span><span class="p">;</span>
    <span class="n">ln_hash</span>  <span class="o">*</span><span class="n">op_proto_table</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_arch_info</span> <span class="n">ln_arch_info</span><span class="p">;</span>

<span class="k">extern</span> <span class="n">ln_arch_info</span> <span class="n">ln_global_arch_info</span><span class="p">;</span>
<span class="cp">#define LN_ARCH ln_global_arch_info</span>
</pre></div>


<p><code>LN_ARCH.arch_table</code> is a hash table that has all registered architectures 
in it. It has registered <code>ln_arch</code> pointers as its values and their <code>arch_name</code>s
as it keys. Besides, <code>LN_ARCH.op_proto_table</code> is another hash table that has
all operators from all architectures in it, that has the registered operator
pointers as its values and their <code>optypes</code>s as its keys.
Thus, developers can look up the registered architectures and operators from
<code>LN_ARCH</code> very convinently.</p></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../js/baidu_analyse.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
