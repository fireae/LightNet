<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../img/favicon.ico">
        <title>Data Structures - LightNet</title>
        <link href="../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../css/font-awesome.min.css" rel="stylesheet">
        <link href="../css/base.css" rel="stylesheet">
        <link href="../css/codehilite.css" rel="stylesheet">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../js/jquery-1.10.2.min.js" defer></script>
        <script src="../js/bootstrap-3.0.3.min.js" defer></script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../index.html">LightNet</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="../index.html">Home</a>
                            </li>
                            <li >
                                <a href="../Getting-Started.html">Getting Started</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="Introduction.html">Introduction</a>
</li>
                                    
<li >
    <a href="Project-Structure.html">Project Structure</a>
</li>
                                    
<li >
    <a href="Build-Options.html">Build Options</a>
</li>
                                    
<li class="active">
    <a href="Data-Structures.html">Data Structures</a>
</li>
                                    
<li >
    <a href="Intermediate-Representation.html">Intermediate Representation</a>
</li>
                                    
<li >
    <a href="Operator-Description.html">Operator Description</a>
</li>
                                    
<li >
    <a href="Optimizer-Description.html">Optimizer Description</a>
</li>
                                    
<li >
    <a href="Miscellaneous.html">Miscellaneous</a>
</li>
                                </ul>
                            </li>
                            <li >
                                <a href="../Hacking.html">Hacking</a>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li >
                                <a rel="next" href="Build-Options.html">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li >
                                <a rel="prev" href="Intermediate-Representation.html">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                            <li>
                                <a href="https://github.com/zhaozhixu/LightNet"><i class="fa fa-github"></i> GitHub</a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#data-structures">Data Structures</a></li>
            <li><a href="#linked-list">Linked List</a></li>
            <li><a href="#queue">Queue</a></li>
            <li><a href="#hash-table">Hash Table</a></li>
            <li><a href="#graph">Graph</a></li>
            <li><a href="#memory-model">Memory Model</a></li>
            <li><a href="#tensor">Tensor</a></li>
            <li><a href="#parameter">Parameter</a></li>
            <li><a href="#operator">Operator</a></li>
            <li><a href="#data-flow-graph">Data Flow Graph</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="data-structures">Data Structures<a class="headerlink" href="#data-structures" title="Permanent link">&para;</a></h1>
<h2 id="linked-list">Linked List<a class="headerlink" href="#linked-list" title="Permanent link">&para;</a></h2>
<p>LightNet uses <code>ln_list</code> to manage a sequence of data structures, which is a 
singlely linked list.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_list</span> <span class="p">{</span>
    <span class="kt">void</span>            <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">ln_list</span>  <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_list</span> <span class="n">ln_list</span><span class="p">;</span>
</pre></div>


<p><code>ln_list</code> doesn't have an empty header node; every node keeps real data.
It has no "create" functions. To create a new list, append an element to
a <code>NULL</code> list. Remember to always use the returned pointer as the newest
list pointer, because the first node may have changed during list alternation
(append, prepend, remove, insert, etc.).</p>
<div class="codehilite"><pre><span></span><span class="n">ln_list</span> <span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">list</span> <span class="o">=</span> <span class="n">ln_list_append</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">first_data</span><span class="p">);</span>
</pre></div>


<p>To traverse the list in order, use a <code>for</code> loop and a temporary variable to 
hold every element of the list, for example:</p>
<div class="codehilite"><pre><span></span><span class="cm">/* list is a ln_list of element type ln_op */</span>
<span class="n">ln_list</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
<span class="n">ln_op</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="n">l</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span> <span class="n">l</span><span class="p">;</span> <span class="n">l</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">op</span> <span class="o">=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">;</span>
    <span class="cm">/* operations on op */</span>
<span class="p">}</span>
</pre></div>


<p><code>ln_list</code> provides a macro for the convinence of traversing the list in order.
However, no list alternation shall be done when using this macro:</p>
<div class="codehilite"><pre><span></span><span class="cm">/* list is a ln_list of element type ln_op */</span>
<span class="n">ln_op</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
<span class="n">LN_LIST_FOREACH</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/* op now hold one element of list */</span>
<span class="p">}</span>
</pre></div>


<p><code>ln_list</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_list *ln_list_prepend(ln_list *list, void *data)</code></strong></p>
<p>Prepend an element at the beginning of the list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_append(ln_list *list, void *data)</code></strong></p>
<p>Append an element at the end of the list.</p>
</li>
<li>
<p><strong><code>void ln_list_free(ln_list *list)</code></strong></p>
<p>Free all nodes in the list.</p>
</li>
<li>
<p><strong><code>void ln_list_free_deep(ln_list *list, void (*free_func)(void *))</code></strong></p>
<p>Free all nodes int the list as well as their elements, which are freed by
<code>free_func</code>.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_nth(ln_list *list, int n)</code></strong></p>
<p>Return the nth node in the list.</p>
</li>
<li>
<p><strong><code>void *ln_list_nth_data(ln_list *list, int n)</code></strong></p>
<p>Return the nth element in the list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove(ln_list *list, void *data)</code></strong></p>
<p>Remove the first node that has <code>data</code> as its element in the list. <code>data</code> is 
compared directly by the pointer value.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove_nth(ln_list *list, int n)</code></strong></p>
<p>Remove the nth node.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove_nth_deep(ln_list *list, int n, void (*free_func)(void *))</code></strong></p>
<p>Remove the nth node as well as its element, which is freed by <code>free_func</code>.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove_custom(ln_list *list, void *data, ln_cmp_func cmp)</code></strong></p>
<p>Remove the first node whose element can be compared with <code>data</code> by <code>cmp</code>
returning 0.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove_custom_deep(ln_list *list, void *data, ln_cmp_func cmp, void (*free_func)(void *))</code></strong></p>
<p>Remove the first node as well as its element which can be compared 
with <code>data</code> by <code>cmp</code> returning 0. The element is freed by <code>free_func</code>.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_remove_all_custom_deep(ln_list *list, void *data, ln_cmp_func cmp, void (*free_func)(void *))</code></strong></p>
<p>Remove all the nodes as well as their elements which can be compared 
with <code>data</code> by <code>cmp</code> returning 0. The elements are freed by <code>free_func</code>.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_insert_before(ln_list *list, void *data, ln_list *node)</code></strong></p>
<p>Insert an element <code>data</code> before <code>node</code> in the list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_insert_nth(ln_list *list, void *data, int n)</code></strong></p>
<p>Insert an element <code>data</code> at the nth position in the list.</p>
</li>
<li>
<p><strong><code>void *ln_list_find(ln_list *list, void *data)</code></strong></p>
<p>Find an element <code>data</code> in the list. <code>data</code> is compared directly by its 
pointer value. Return the element if it's found, else return <code>NULL</code>.</p>
</li>
<li>
<p><strong><code>void *ln_list_find_custom(ln_list *list, void *data, ln_cmp_func cmp)</code></strong></p>
<p>Find an element in the list, which can be compared with <code>data</code> by <code>cmp</code>
returning 0. Return the element if it's found, else return <code>NULL</code>.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_find_all_custom(ln_list *list, void *data, ln_cmp_func cmp)</code></strong></p>
<p>Find all elements that can be compared with <code>data</code> by <code>cmp</code> returning 0.
Return them in a new list.</p>
</li>
<li>
<p><strong><code>int ln_list_position(ln_list *list, ln_list *node)</code></strong></p>
<p>Return the position index of <code>node</code> in the list.</p>
</li>
<li>
<p><strong><code>int ln_list_index(ln_list *list, void *data)</code></strong></p>
<p>Return the position index of the first occurence of <code>data</code> in the list.
<code>data</code> is compared directly by its pointer value.</p>
</li>
<li>
<p><strong><code>int ln_list_index_custom(ln_list *list, void *data, ln_cmp_func cmp)</code></strong></p>
<p>Return the position index of the first node whose element can be compared
with <code>data</code> by <code>cmp</code> returning 0.</p>
</li>
<li>
<p><strong><code>int ln_list_length(ln_list *list)</code></strong></p>
<p>Return the length of the list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_reverse(ln_list *list)</code></strong></p>
<p>Reverse the nodes in the list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_from_array_size_t(size_t *array, size_t n)</code></strong></p>
<p>Create the list from an array with length <code>n</code>, whose elements are of type
<code>size_t</code>. The elements if the list have the same pointer values as the 
array's elements' values.</p>
</li>
<li>
<p><strong><code>ln_list *ln_list_copy(ln_list *list)</code></strong></p>
<p>Create a new list, whose elements' values are the same as <code>list</code>'s 
elements' values.</p>
</li>
</ul>
<h2 id="queue">Queue<a class="headerlink" href="#queue" title="Permanent link">&para;</a></h2>
<p><code>ln_queue</code> is a simple single-in single-out linked list, using two list nodes
for its head and tail.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_queue</span> <span class="p">{</span>
    <span class="n">ln_list</span>  <span class="o">*</span><span class="n">head</span><span class="p">;</span>
    <span class="n">ln_list</span>  <span class="o">*</span><span class="n">tail</span><span class="p">;</span>
    <span class="kt">size_t</span>    <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_queue</span> <span class="n">ln_queue</span><span class="p">;</span>
</pre></div>


<p><code>ln_queue</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_queue *ln_queue_create(void)</code></strong></p>
<p>Create an empty queue.</p>
</li>
<li>
<p><strong><code>ln_queue *ln_queue_enqueue(ln_queue *queue, void *data)</code></strong></p>
<p>Add an element to the head of the queue. Create a new queue if 
<code>queue == NULL</code>.</p>
</li>
<li>
<p><strong><code>void *ln_queue_dequeue(ln_queue *queue)</code></strong></p>
<p>Remove and return the element at the tail of the queue.</p>
</li>
<li>
<p><strong><code>void ln_queue_free(ln_queue *queue)</code></strong></p>
<p>Free the queue.</p>
</li>
</ul>
<h2 id="hash-table">Hash Table<a class="headerlink" href="#hash-table" title="Permanent link">&para;</a></h2>
<p>LightNet uses <code>ln_hash</code> to construct key-value pairs that can be used for quick
lookups. <code>ln_hash</code> is an opaque structure in other modules. It uses separate
chaining method to store the key-value pairs, and its implementation references
the <a href="http://hg.openjdk.java.net/jdk7/jdk7/jdk/file/9b8c96f96a0f/src/share/classes/java/util/HashMap.java">HashMap</a> in OpenJDK 7.</p>
<p><code>ln_hash</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_hash *ln_hash_create_full(ln_hash_func hash_func, ln_cmp_func cmp_func, ln_free_func free_k_func, ln_free_func free_v_func, int init_capacity, float load_factor)</code></strong></p>
<p>Create a hash table with full arguments.</p>
<p><code>hash_func</code> is the hash function of the key's data type.</p>
<p><code>cmp_func</code> is the comparison function of the key's data type.</p>
<p><code>free_k_func</code> is the free function of the key's data type. If it's <code>NULL</code>,
<code>ln_hash</code> will not free the key when it is removed.</p>
<p><code>free_v_func</code> is the free function of the value's data type. If it's <code>NULL</code>,
<code>ln_hash</code> will not free the value when it is removed.</p>
<p><code>init_capacity</code> is the initial capacity of the table.</p>
<p><code>load_factor</code> is the load factor of the table. When the ratio of the number
of elements to the capacity exceeds this factor, the table will expand its
capacity.</p>
</li>
<li>
<p><strong><code>ln_hash *ln_hash_create(ln_hash_func hash_func, ln_cmp_func cmp_func, ln_free_func free_k_func, ln_free_func free_v_func)</code></strong></p>
<p>Create a hash table with some default arguments.</p>
<p><code>hash_func</code> is the hash function of the key's data type.</p>
<p><code>cmp_func</code> is the comparison function of the key's data type.</p>
<p><code>free_k_func</code> is the free function of the key's data type. If it's <code>NULL</code>,
<code>ln_hash</code> will not free the key when it is removed.</p>
<p><code>free_v_func</code> is the free function of the value's data type. If it's <code>NULL</code>,
<code>ln_hash</code> will not free the value when it is removed.</p>
</li>
<li>
<p><strong><code>void ln_hash_free(ln_hash *hash)</code></strong></p>
<p>Free a hash table. Also free the keys and/or values if either of the free
functions is provided when creating this table.</p>
</li>
<li>
<p><strong><code>void ln_hash_init(ln_hash *hash, ln_hash_init_entry *init_array)</code></strong></p>
<p>Initialize an empty hash table with the key-value pairs in <code>init_array</code>. 
The elements of <code>init_array</code> are defined as:</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_hash_init_entry</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_hash_init_entry</span> <span class="n">ln_hash_init_entry</span><span class="p">;</span>
</pre></div>


<p>This array should be ended with a <code>{NULL, NULL}</code> entry.</p>
</li>
<li>
<p><strong><code>int ln_hash_insert(ln_hash *hash, const void *key, void *value)</code></strong></p>
<p>Insert a key-value pair to the hash table. Return 0 if the key already
exists and the old value will be replaced by <code>value</code> (it will be freed if
its free function is provided when creating the table), else return 1.</p>
</li>
<li>
<p><strong><code>void *ln_hash_find(ln_hash *hash, const void *key)</code></strong></p>
<p>Find a value in the hash table with <code>key</code>. If it is found, return the value,
else return <code>NULL</code>. In case of existing legal <code>NULL</code> values, use 
<code>ln_hash_find_extended</code>.</p>
</li>
<li>
<p><strong><code>int ln_hash_find_extended(ln_hash *hash, const void *key, void **found_key, void **found_value)</code></strong></p>
<p>Find a value in the hash table with <code>key</code>. If it is found, return 1, else
return 0. The found key and value will be stored in <code>found_key</code> and 
<code>found_value</code> respectively. If either of <code>found_key</code> or <code>found_value</code> is
<code>NULL</code>, the found key or value will be ignored.</p>
</li>
<li>
<p><strong><code>int ln_hash_remove(ln_hash *hash, const void *key)</code></strong></p>
<p>Remove a key-value pair in the hash table. The key and/or value will also be
freed if either of the free functions is provided when creating the table.</p>
</li>
<li>
<p><strong><code>int ln_hash_size(ln_hash *hash)</code></strong></p>
<p>Return the number of key-value pairs in the hash table.</p>
</li>
</ul>
<h2 id="graph">Graph<a class="headerlink" href="#graph" title="Permanent link">&para;</a></h2>
<p>LightNet use <code>ln_graph</code> to represent computing graphs. <code>ln_graph</code> uses ajiacency
list method to implement directed graphs, which uses a linked list to store the
graph nodes; every node has its in-degree, out-degree,  a list of its previous
edges and nodes, and a list of its next edges and nodes.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_graph_node</span> <span class="p">{</span>
    <span class="kt">void</span>        <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="n">ln_list</span>     <span class="o">*</span><span class="n">out_edge_nodes</span><span class="p">;</span>    <span class="cm">/* data type is ln_graph_edge_node */</span>
    <span class="n">ln_list</span>     <span class="o">*</span><span class="n">in_edge_nodes</span><span class="p">;</span>
    <span class="n">ln_cmp_func</span>  <span class="n">node_data_cmp</span><span class="p">;</span>
    <span class="kt">size_t</span>       <span class="n">indegree</span><span class="p">;</span>
    <span class="kt">size_t</span>       <span class="n">outdegree</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_graph_node</span> <span class="n">ln_graph_node</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ln_graph_edge_node</span> <span class="p">{</span>         <span class="cm">/* store the ajiacency edge and node */</span>
    <span class="kt">void</span>           <span class="o">*</span><span class="n">edge_data</span><span class="p">;</span>
    <span class="n">ln_graph_node</span>  <span class="o">*</span><span class="n">node</span><span class="p">;</span>
    <span class="n">ln_cmp_func</span>     <span class="n">edge_data_cmp</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_graph_edge_node</span> <span class="n">ln_graph_edge_node</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ln_graph</span> <span class="p">{</span>
    <span class="kt">size_t</span>       <span class="n">size</span><span class="p">;</span>
    <span class="n">ln_list</span>     <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>             <span class="cm">/* data type is ln_graph_node */</span>
    <span class="n">ln_cmp_func</span>  <span class="n">node_data_cmp</span><span class="p">;</span>
    <span class="n">ln_cmp_func</span>  <span class="n">edge_data_cmp</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_graph</span> <span class="n">ln_graph</span><span class="p">;</span>
</pre></div>


<p><code>ln_graph</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_graph_node *ln_graph_node_create(void *data, ln_cmp_func node_data_cmp)</code></strong></p>
<p>Create a graph node with node data and the comparison function of node data.</p>
</li>
<li>
<p><strong><code>void ln_graph_node_free(ln_graph_node *node)</code></strong></p>
<p>Free a graph node.</p>
</li>
<li>
<p><strong><code>ln_graph_edge_node *ln_graph_edge_node_create(void *edge_data, ln_graph_node *node, ln_cmp_func edge_data_cmp)</code></strong></p>
<p>Create a graph edge node with edge data, the graph node, and the comparison
function of edge data.</p>
</li>
<li>
<p><strong><code>void ln_graph_edge_node_free(ln_graph_edge_node *edge_node)</code></strong></p>
<p>Free a graph edge node.</p>
</li>
<li>
<p><strong><code>ln_graph *ln_graph_create(ln_cmp_func node_cmp, ln_cmp_func edge_cmp)</code></strong></p>
<p>Create an empty graph with the comparison functions of node data and edge
data.</p>
</li>
<li>
<p><strong><code>void ln_graph_free(ln_graph *graph)</code></strong></p>
<p>Free a graph.</p>
</li>
<li>
<p><strong><code>ln_graph_node *ln_graph_add(ln_graph *graph, void *data)</code></strong></p>
<p>Create and add a node to the graph with <code>data</code> as node data. Return the 
created node.</p>
</li>
<li>
<p><strong><code>ln_graph_node *ln_graph_find(ln_graph *graph, void *data)</code></strong></p>
<p>Find the first graph node that has the same data as <code>data</code>. Return the found
node if the node is found, else return <code>NULL</code>.</p>
</li>
<li>
<p><strong><code>void ln_graph_link(ln_graph *graph, void *data1, void *data2, void *edge_data)</code></strong></p>
<p>Link the first node that has the same data as <code>data1</code> to the first node 
that has the same data as <code>data2</code>, with a newly created edge of <code>edge_data</code>.</p>
</li>
<li>
<p><strong><code>void ln_graph_link_node(ln_graph *graph, ln_graph_node *node1, ln_graph_node *node2, void *edge_data)</code></strong></p>
<p>Link <code>node1</code> to <code>node2</code> with a newly created edge of <code>edge_data</code>.</p>
</li>
<li>
<p><strong><code>void *ln_graph_unlink(ln_graph *graph, void *data1, void *data2, void *edge_data)</code></strong></p>
<p>Unlink the first node that has the same data as <code>data1</code> and the first node 
that has the same data as <code>data2</code>, with a edge of <code>edge_data</code>. If 
<code>edge_data == NULL</code>, only compare <code>data1</code> and <code>data2</code>.</p>
</li>
<li>
<p><strong><code>void *ln_graph_unlink_node(ln_graph_node *node1, ln_graph_node *node2, void *edge_data)</code></strong></p>
<p>Unlink <code>node1</code> and <code>node2</code> with a edge of <code>edge_data</code>. If
<code>edge_data == NULL</code>, only compare <code>data1</code> and <code>data2</code>.</p>
</li>
<li>
<p><strong><code>ln_graph *ln_graph_copy(ln_graph *graph)</code></strong></p>
<p>Copy a graph.</p>
</li>
<li>
<p><strong><code>int ln_graph_num_outlier(ln_graph *graph)</code></strong></p>
<p>Return the number of nodes that don't link with any other nodes.</p>
</li>
<li>
<p><strong><code>int ln_graph_topsort(ln_graph *graph, ln_list **layers)</code></strong></p>
<p>Run topological sort on the graph. Sorted nodes are returned in <code>layers</code>,
which is a pointer to a list of layers. All nodes in the same layer has the
topological order. 
Return -1 if the graph has a cycle, else return the number of layers.</p>
</li>
<li>
<p><strong><code>void ln_graph_free_topsortlist(ln_list *layers)</code></strong></p>
<p>Free the layers return by <code>ln_graph_topsort</code>.</p>
</li>
<li>
<p><strong><code>void ln_graph_fprint(FILE *fp, ln_graph *graph, ln_fprint_func print_node, ln_fprint_func print_edge)</code></strong></p>
<p>Print the graph to stream <code>fp</code>. Graph node data are printed by <code>print_node</code>.
Graph edge data are printed by <code>print_edge</code>.</p>
</li>
</ul>
<h2 id="memory-model">Memory Model<a class="headerlink" href="#memory-model" title="Permanent link">&para;</a></h2>
<p>Every computing device in heterogeneous platforms may have its own type of
memory. LightNet uses an enumeration type <code>ln_mem_type</code> to describe them.
Every <code>ln_mem_type</code> should have an instance of <code>ln_mem_info</code> in <code>ln_mem.c</code>.</p>
<div class="codehilite"><pre><span></span><span class="k">enum</span> <span class="n">ln_mem_type</span> <span class="p">{</span>
    <span class="n">LN_MEM_NONE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">LN_MEM_CPU</span><span class="p">,</span>
<span class="cp">#ifdef LN_CUDA</span>
    <span class="n">LN_MEM_CUDA</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="cm">/* ... may be other mem types here */</span>
    <span class="n">LN_MEM_TYPE_SIZE</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">ln_mem_type</span> <span class="n">ln_mem_type</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ln_mem_info</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span>  <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">void</span>      <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">alloc_func</span><span class="p">)(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
    <span class="kt">void</span>       <span class="p">(</span><span class="o">*</span><span class="n">free_func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>
    <span class="kt">void</span>      <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">memset_func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
    <span class="kt">size_t</span>       <span class="n">max_size</span><span class="p">;</span>
    <span class="kt">size_t</span>       <span class="n">align_size</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_mem_info</span> <span class="n">ln_mem_info</span><span class="p">;</span>
</pre></div>


<p>Every <code>ln_mem_type</code> has its own information, in which <code>alloc_func</code>, 
<code>free_func</code>, <code>memset_func</code> are its memory operations, as <code>malloc</code>, <code>free</code>,
<code>memset</code> in the standard C library. <code>max_size</code> is the maximum bytes the memory
type can store. <code>align_size</code> is the alignment bytes the memory type requires.</p>
<p><code>ln_mem_type</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>const char *ln_mem_type_name(ln_mem_type mtype)</code></strong></p>
<p>Return the name of <code>mtype</code>.</p>
</li>
<li>
<p><strong><code>const ln_mem_info ln_mem_type_info(ln_mem_type mtype)</code></strong></p>
<p>Return the <code>ln_mem_info</code> of <code>mtype</code>.</p>
</li>
<li>
<p><strong><code>ln_copy_func ln_mem_type_copy_func(ln_mem_type dst_mtype, ln_mem_type src_mtype)</code></strong></p>
<p>Return the copy function from <code>src_mtype</code> to <code>dst_mtype</code>, as <code>memcpy</code> in the
standard C library.</p>
</li>
</ul>
<p>Besides, LightNet uses virtual memory pools to make overall arrangements for
the memory allocations and releases of all kinds of memory types.
This step pre-plans the memory offsets of tensors, which can be converted to 
real memory addresses in run time.
<code>ln_mem_pool</code> is the virtual memory pool structure.</p>
<p><code>ln_mem_pool</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_mem_pool *ln_mem_pool_create(size_t size, size_t align_size)</code></strong></p>
<p>Create a virtual memory pool.</p>
</li>
<li>
<p><strong><code>void ln_mem_pool_free(ln_mem_pool *mem_pool)</code></strong></p>
<p>Free a virtual memory pool.</p>
</li>
<li>
<p><strong><code>size_t ln_mem_pool_alloc(ln_mem_pool *mem_pool, size_t size)</code></strong></p>
<p>Return the allocated memory offset (starting from 0) from the memory pool.</p>
</li>
<li>
<p><strong><code>void ln_mem_pool_dealloc(ln_mem_pool *mem_pool, size_t addr)</code></strong></p>
<p>Deallocate a memory offset.</p>
</li>
<li>
<p><strong><code>int ln_mem_pool_exist(ln_mem_pool *mem_pool, size_t addr)</code></strong></p>
<p>Test if a memory offset is allocated before.</p>
</li>
<li>
<p><strong><code>void ln_mem_pool_dump(ln_mem_pool *mem_pool, FILE *fp)</code></strong></p>
<p>Dump the memory layout of the memory pool.</p>
</li>
<li>
<p><strong><code>ln_hash *ln_mem_pool_table_create(void)</code></strong></p>
<p>Create a hash table of all memory pools. 
The table takes <code>ln_mem_type</code> as keys and <code>ln_mem_pool</code> as values.</p>
</li>
<li>
<p><strong><code>void ln_mem_pool_table_free(ln_hash *mpt)</code></strong></p>
<p>Free the memory pool hash table returned by <code>ln_mem_pool_table_create</code>.</p>
</li>
</ul>
<h2 id="tensor">Tensor<a class="headerlink" href="#tensor" title="Permanent link">&para;</a></h2>
<p>LightNet uses <code>ln_tensor</code> as the basic data storage structure.
<code>ln_tensor</code> is used as operator's input and output, such as a
convolution's input image, output feature map, and weights.
<code>ln_tensor</code> further uses <a href="https://github.com/zhaozhixu/TensorLight">TensorLight</a>
as its basic tensor operation library, which is seperated from LightNet on
purpose so that it can be used widely beyond LightNet.</p>
<p>TensorLight implements many universal tensor operations. There are some simple
operations such as slice, transpose, concatation, relu, as well as some 
complicated operations such as bounding boxes' coordinate transformation,
YOLO's object detection. Developers are welcomed to add their own useful
operations to TensorLight, which can be used not only in LightNet, but also 
in other projects.</p>
<p>In both projects, a tensor refers to a <code>tl_tensor</code> structure, which has the
tensor's meta infomation and its data pointer.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">tl_tensor</span> <span class="p">{</span>
    <span class="n">tl_dtype</span>          <span class="n">dtype</span><span class="p">;</span>          <span class="cm">/* data type */</span>
    <span class="kt">int</span>               <span class="n">len</span><span class="p">;</span>            <span class="cm">/* number of elements */</span>
    <span class="kt">int</span>               <span class="n">ndim</span><span class="p">;</span>           <span class="cm">/* number of dimensions */</span>
    <span class="kt">int</span>              <span class="o">*</span><span class="n">dims</span><span class="p">;</span>           <span class="cm">/* array of dimensions */</span>
    <span class="kt">void</span>             <span class="o">*</span><span class="n">data</span><span class="p">;</span>           <span class="cm">/* data pointer */</span>
    <span class="k">struct</span> <span class="n">tl_tensor</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>          <span class="cm">/* data owner, NULL if it&#39;s itself */</span>
    <span class="kt">void</span>             <span class="o">*</span><span class="n">backend_data</span><span class="p">;</span>   <span class="cm">/* for other backend dependent data */</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">tl_tensor</span> <span class="n">tl_tensor</span><span class="p">;</span>
</pre></div>


<p>A tensor's data type is represented by a enumeration type <code>tl_dtype</code>. It 
supports many common data types such as double, float, 32/16/8 bit 
signed/unsigned integers, and bool.</p>
<div class="codehilite"><pre><span></span><span class="k">enum</span> <span class="n">tl_dtype</span> <span class="p">{</span>
    <span class="n">TL_DTYPE_INVALID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
    <span class="n">TL_DOUBLE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">TL_FLOAT</span><span class="p">,</span>
    <span class="n">TL_INT32</span><span class="p">,</span>
    <span class="n">TL_INT16</span><span class="p">,</span>
    <span class="n">TL_INT8</span><span class="p">,</span>
    <span class="n">TL_UINT32</span><span class="p">,</span>
    <span class="n">TL_UINT16</span><span class="p">,</span>
    <span class="n">TL_UINT8</span><span class="p">,</span>
    <span class="n">TL_BOOL</span><span class="p">,</span>
    <span class="n">TL_DTYPE_SIZE</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">tl_dtype</span> <span class="n">tl_dtype</span><span class="p">;</span>
</pre></div>


<p><code>tl_tensor</code> supports many tensor operations, see <a href="https://github.com/zhaozhixu/TensorLight">TensorLight</a> for more details.</p>
<p>In LightNet, all tensors in a NN model are managed by a tensor table. The tensor
table is a hash table, with tensors' names as its keys and tensor table entries
as its values. The tensor table entry structure is defined as follows.</p>
<div class="codehilite"><pre><span></span><span class="cm">/* NOTE: ALWAYS access tensor entry via its name in tensor table, since the</span>
<span class="cm">   entry may be not the same during passes. It is owned by the tensor table. */</span>
<span class="k">struct</span> <span class="n">ln_tensor_entry</span> <span class="p">{</span>
    <span class="kt">char</span>        <span class="o">*</span><span class="n">name</span><span class="p">;</span>          <span class="cm">/* tensor name */</span>
    <span class="n">tl_tensor</span>   <span class="o">*</span><span class="n">tensor</span><span class="p">;</span>        <span class="cm">/* pointer to the underlying tl_tensor */</span>
    <span class="kt">char</span>        <span class="o">*</span><span class="n">owner</span><span class="p">;</span>         <span class="cm">/* owner tensor&#39;s name of the tensor&#39;s data */</span>
    <span class="kt">char</span>        <span class="o">*</span><span class="n">creater</span><span class="p">;</span>       <span class="cm">/* operator name who creates the tensor */</span>
    <span class="kt">size_t</span>       <span class="n">offset</span><span class="p">;</span>        <span class="cm">/* offset address of the tensor&#39;s data */</span>
    <span class="kt">int</span>          <span class="n">isstatic</span><span class="p">;</span>      <span class="cm">/* the tensor is static or not */</span>
    <span class="n">ln_mem_type</span>  <span class="n">mtype</span><span class="p">;</span>         <span class="cm">/* memory type */</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_tensor_entry</span> <span class="n">ln_tensor_entry</span><span class="p">;</span>
</pre></div>


<p>Every tensor must be created by an operator, and <code>creater</code> records that
operator's name. Considering the computing efficiency, some tensors may share
the same underlying data pointer, in which case <code>owner</code> records the name of the
tensor who actually owns the data. <code>offset</code> is the relative address assigned to
the tensor in memory planning process, and it is initially 0, which is invalid 
at run time. Some tensors' memory may not be freed after allocation, in which
case <code>isstatic</code> should be labeled as 1 to indicate that it's static. Finally,
<code>mtype</code> is the memory type of the tensor's data.</p>
<p><code>ln_tensor_entry</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_tensor_entry *ln_tensor_entry_create(const char *name, tl_tensor *tensor)</code></strong></p>
<p>Create a tensor entry with <code>name</code> and the underlying <code>tensor</code>.</p>
</li>
<li>
<p><strong><code>void ln_tensor_entry_free(ln_tensor_entry *entry)</code></strong></p>
<p>Free a tensor entry.</p>
</li>
<li>
<p><strong><code>void ln_tensor_entry_free_tensor_too(ln_tensor_entry *entry)</code></strong></p>
<p>Free the tensor entry as well as the underlying <code>tensor</code>,
but not free the raw data pointer <code>tensor-&gt;data</code>.</p>
</li>
<li>
<p><strong><code>void ln_tensor_entry_set_owner(ln_tensor_entry *entry, ln_hash *tensor_table, char *owner)</code></strong></p>
<p>Set the owner tensor name to <code>owner</code> with which the tensor entry
shares its data.</p>
</li>
<li>
<p><strong><code>void ln_tensor_entry_set_creater(ln_tensor_entry *entry, const char *creater)</code></strong></p>
<p>Set the name of the creater operator of this tensor entry to <code>creater</code>.</p>
</li>
</ul>
<p>The tensor table supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_hash *ln_tensor_table_create(void)</code></strong></p>
<p>Create a tensor table.</p>
</li>
<li>
<p><strong><code>int ln_tensor_table_insert(ln_hash *table, ln_tensor_entry *entry)</code></strong></p>
<p>Insert a new tensor entry to the tensor table. The behaviour is consistent
with <code>ln_hash_insert()</code>.</p>
</li>
<li>
<p><strong><code>int ln_tensor_table_remove(ln_hash *table, const char *name)</code></strong></p>
<p>Remove a tensor entry <code>name</code> from the tensor table.</p>
</li>
<li>
<p><strong><code>ln_tensor_entry *ln_tensor_table_find(ln_hash *table, const char *name)</code></strong></p>
<p>Find a tensor entry <code>name</code> in the tensor table.</p>
</li>
<li>
<p><strong><code>void ln_tensor_table_free(ln_hash *table);</code></strong></p>
<p>Free the tensor table as well as all its tensor entries.</p>
</li>
<li>
<p><strong><code>void ln_tensor_table_set_data(ln_hash *table, const char *name, const void *data)</code></strong></p>
<p>Copy <code>data</code> to the underlying memory region of tensor entry <code>name</code>.</p>
</li>
<li>
<p><strong><code>void *ln_tensor_table_get_data(ln_hash *table, const char *name, void *data)</code></strong></p>
<p>Copy the underlying memory region of tensor entry <code>name</code> to <code>data</code>.</p>
</li>
<li>
<p><strong><code>size_t ln_tensor_table_data_size(ln_hash *table, const char *name)</code></strong></p>
<p>Get the data size of the tensor entry <code>name</code> in bytes.</p>
</li>
<li>
<p><strong><code>void ln_tensor_table_load_trt_weight_file(ln_hash *table, const char *file)</code></strong></p>
<p>Copy the weights from <code>file</code> to the tensor entries accordingly. <code>file</code>
should follow the weight format of TensorRT, which can be showned with
<code>tools/genwts.pl -h</code>.</p>
</li>
</ul>
<p>When removing a tensor or inserting a different tensor with the same name 
as another tensor, the tensor table will free the old table entry and its 
<code>tensor</code> field, but not free <code>tensor-&gt;data</code>. So we should always insert tensors 
with <code>NULL</code> data.</p>
<p>Besides tensor table entry, this mudule also defines a tensor list entry
structure <code>ln_tensor_list_entry</code>.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_tensor_list_entry</span> <span class="p">{</span>
    <span class="kt">char</span>            <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="kt">char</span>            <span class="o">*</span><span class="n">arg_name</span><span class="p">;</span>
    <span class="kt">size_t</span>           <span class="n">offset</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_tensor_list_entry</span> <span class="n">ln_tensor_list_entry</span><span class="p">;</span>
</pre></div>


<p><code>ln_tensor_list_entry</code> is used in an operator's input/output tensor list. <code>name</code>
and <code>offset</code> are the same as those in the tensor's table entry. <code>name</code> is used
to find the tensor table entry from the operator. <code>offset</code> is used to store
the memory-planned address in the optimized output operator stream. <code>arg_name</code>
is the argument name of the tensor in the operator, such as "stride" in an 
"conv2d" operator.</p>
<p><code>ln_tensor_list_entry</code> and tensor list supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_tensor_list_entry *ln_tensor_list_entry_create(const char *arg_name, const char *name)</code></strong></p>
<p>Create a tensor list entry.</p>
</li>
<li>
<p><strong><code>void ln_tensor_list_entry_free(ln_tensor_list_entry *entry)</code></strong></p>
<p>Free a tensor list entry.</p>
</li>
<li>
<p><strong><code>ln_list *ln_tensor_list_append(ln_list *list, const char *arg_name, const char *name)</code></strong></p>
</li>
</ul>
<p>Append to a tensor list with an entry that has <code>arg_name</code> and <code>name</code>.</p>
<ul>
<li>
<p><strong><code>void ln_tensor_list_free(ln_list *list)</code></strong></p>
<p>Free a tensor list as well as its entries.</p>
</li>
<li>
<p><strong><code>ln_list *ln_tensor_list_copy(ln_list *list)</code></strong></p>
<p>Copy a tensor list. Entries are newly created for the new list.</p>
</li>
<li>
<p><strong><code>char *ln_tensor_list_find_name(ln_list *list, const char *arg_name)</code></strong></p>
<p>Return the tensor list entry's name that has <code>arg_name</code> from the tensor list.</p>
</li>
<li>
<p><strong><code>ln_tensor_list_entry *ln_tensor_list_find_by_arg_name(ln_list *list, const char *arg_name)</code></strong></p>
<p>Find the tensor list entry that has <code>arg_name</code> from the tensor list.</p>
</li>
<li>
<p><strong><code>ln_tensor_list_entry *ln_tensor_list_find_by_name(ln_list *list, const char *name)</code></strong></p>
<p>Find the tensor list entry that has <code>name</code> from the tensor list.</p>
</li>
<li>
<p><strong><code>ln_tensor_entry *ln_tensor_list_find_entry(ln_list *list, ln_hash *tensor_table, const char *arg_name)</code></strong></p>
<p>Find the tensor entry from <code>tensor_table</code> that has the same name with the 
tensor list entry from <code>list</code> that has <code>arg_name</code> as its arg name.</p>
</li>
<li>
<p><strong><code>int ln_tensor_list_length(ln_list *list)</code></strong></p>
<p>Return the tensor list length.</p>
</li>
<li>
<p><strong><code>int ln_tensor_list_unique_arg_name(ln_list *list, char *buf, const char *prefix)</code></strong></p>
<p>Create an arg name that is unique in the tensor list.
The arg name is prefixed with <code>prefix</code> and subfixed with a serial number,
so that unique names will be created for a same prefix.
The arg name' length should be less than <code>LN_MAX_NAME_LEN</code>. If its length
exceeds that limit, an internal error will be emited and the program will 
abort. The arg name  will be printed in <code>buf</code>. The return value is the 
subfixed number.</p>
</li>
</ul>
<h2 id="parameter">Parameter<a class="headerlink" href="#parameter" title="Permanent link">&para;</a></h2>
<p>Like <code>ln_tensor_list_entry</code>, LightNet also uses <code>ln_param_entry</code> to represent 
parameters used in an operator's parameter list. Different from <code>ln_tensor</code>,
<code>ln_param_entry</code> is often used as the configuration for the operator, but
not the input or output of the operator in the semantic meaning, such as the
stride, padding or dilation configuration for a convolution operator.</p>
<div class="codehilite"><pre><span></span><span class="k">enum</span> <span class="n">ln_param_type</span> <span class="p">{</span>
    <span class="cm">/* NULL should always be the first type */</span>
    <span class="n">LN_PARAM_NULL</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">LN_PARAM_STRING</span><span class="p">,</span>
    <span class="n">LN_PARAM_NUMBER</span><span class="p">,</span>
    <span class="n">LN_PARAM_BOOL</span><span class="p">,</span>
    <span class="n">LN_PARAM_ARRAY_STRING</span><span class="p">,</span>
    <span class="n">LN_PARAM_ARRAY_NUMBER</span><span class="p">,</span>
    <span class="n">LN_PARAM_ARRAY_BOOL</span><span class="p">,</span>
    <span class="n">LN_PARAM_INVALID</span>
    <span class="cm">/* INVALID should always be the last type */</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">enum</span> <span class="n">ln_param_type</span> <span class="n">ln_param_type</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">ln_param_entry</span> <span class="p">{</span>
    <span class="kt">char</span>          <span class="o">*</span><span class="n">arg_name</span><span class="p">;</span>           <span class="cm">/* argument name in tensor list */</span>
    <span class="n">ln_param_type</span>  <span class="n">type</span><span class="p">;</span>               <span class="cm">/* parameter type */</span>
    <span class="kt">int</span>            <span class="n">array_len</span><span class="p">;</span>          <span class="cm">/* array length if it&#39;s an array */</span>
    <span class="kt">double</span>         <span class="n">value_double</span><span class="p">;</span>       <span class="cm">/* double value, as belows... */</span>
    <span class="kt">float</span>          <span class="n">value_float</span><span class="p">;</span>
    <span class="kt">int</span>            <span class="n">value_int</span><span class="p">;</span>
    <span class="n">ln_bool</span>        <span class="n">value_bool</span><span class="p">;</span>
    <span class="kt">char</span>          <span class="o">*</span><span class="n">value_string</span><span class="p">;</span>
    <span class="kt">char</span>         <span class="o">**</span><span class="n">value_array_string</span><span class="p">;</span>
    <span class="kt">double</span>        <span class="o">*</span><span class="n">value_array_double</span><span class="p">;</span>
    <span class="kt">float</span>         <span class="o">*</span><span class="n">value_array_float</span><span class="p">;</span>
    <span class="kt">int</span>           <span class="o">*</span><span class="n">value_array_int</span><span class="p">;</span>
    <span class="n">ln_bool</span>       <span class="o">*</span><span class="n">value_array_bool</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_param_entry</span> <span class="n">ln_param_entry</span><span class="p">;</span>
</pre></div>


<p>The enum type <code>ln_param_type</code> represents the param value's data type.
There are three special case here:</p>
<ol>
<li>If the param type is <code>LN_PARAM_NULL</code>, the param entry's <code>value_...</code> fields
are ignored and the param value is treated as <code>null</code>, which could represent some
special uncommon values. </li>
<li>If the param type is <code>LN_PARAM_NUMBER</code>, the param entry's <code>value_double</code>,
<code>value_float</code>, <code>value_int</code> are set in the same time when setting the param's
value with <code>ln_param_set_satu_...</code> functions, and when the number is 
beyond the data type's representable region, the maximum or minimum value will
be set as the data type's value.</li>
<li>If the param type is <code>LN_PARAM_ARRAY_NUMBER</code>, the param entry's 
<code>value_array_double</code>, <code>value_array_float</code>, <code>value_array_int</code> are set in the same
time when setting the param's value with <code>ln_param_set_satu_...</code> functions, 
and when an array's element is beyond the data type's representable 
region, the maximum or minimum value will be set as the number array's element.</li>
</ol>
<p><code>ln_param_entry</code> supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_param_entry *ln_param_entry_create(const char *arg_name, ln_param_type type)</code></strong></p>
<p>Create a param entry.</p>
</li>
<li>
<p><strong><code>void ln_param_entry_free(ln_param_entry *entry)</code></strong></p>
<p>Free a param entry.</p>
</li>
<li>
<p><strong><code>const char *ln_param_type_name(ln_param_type type)</code></strong></p>
<p>Return the param type's string representation.</p>
</li>
<li>
<p><strong><code>ln_param_entry *ln_param_entry_copy(const ln_param_entry *pe)</code></strong></p>
<p>Copy the param entry.</p>
</li>
<li>
<p><strong><code>void ln_param_vset(ln_param_entry *entry, va_list ap)</code></strong></p>
<p>Used to write param setting functions with variable-length parameters.</p>
</li>
<li>
<p><strong><code>void ln_param_set(ln_param_entry *entry, ...)</code></strong></p>
<p>Set the param entry's value. The argument after <code>entry</code> will be interpreted
as the appropriate data type according to <code>entry-&gt;type</code>, and set as the 
entry value.</p>
</li>
<li>
<p><strong><code>void ln_param_set_null(ln_param_entry *entry)</code></strong></p>
<p>Set the param entry's type as <code>LN_PARAM_NULL</code>.</p>
</li>
<li>
<p><strong><code>void ln_param_set_bool(ln_param_entry *entry, ln_bool bool_value)</code></strong></p>
<p>Set the param entry's bool value.</p>
</li>
<li>
<p><strong><code>void ln_param_set_string(ln_param_entry *entry, const char *string)</code></strong></p>
<p>Set the param entry's string value.</p>
</li>
<li>
<p><strong><code>void ln_param_set_satu_number(ln_param_entry *entry, double number)</code></strong></p>
<p>Set the param entry's number value. The entry's <code>value_double</code>, 
<code>value_float</code>, <code>value_int</code> fields are set in the same time.
<code>value_float</code>, <code>value_int</code> are set in a saturation manner.</p>
</li>
<li>
<p><strong><code>void ln_param_set_satu_array_number(ln_param_entry *entry, int array_len, const double *array_number)</code></strong></p>
<p>Set the param entry's number array value. The entry's <code>value_array_double</code>, 
<code>value_array_float</code>, <code>value_array_int</code> fields are set in the same time.
<code>value_array_float</code>, <code>value_array_int</code> are set in a saturation manner.</p>
</li>
<li>
<p><strong><code>void ln_param_set_satu_array_double(ln_param_entry *entry, int array_len, const double *array_number)</code></strong></p>
<p>Set the param entry's number array value. The entry's <code>value_array_double</code>, 
<code>value_array_float</code>, <code>value_array_int</code> fields are set in the same time.
<code>value_array_float</code>, <code>value_array_int</code> are set in a saturation manner.</p>
</li>
<li>
<p><strong><code>void ln_param_set_satu_array_float(ln_param_entry *entry, int array_len, const float *array_number)</code></strong></p>
<p>Set the param entry's number array value. The entry's <code>value_array_double</code>, 
<code>value_array_float</code>, <code>value_array_int</code> fields are set in the same time.
<code>value_array_int</code> is set in a saturation manner.</p>
</li>
<li>
<p><strong><code>void ln_param_set_satu_array_int(ln_param_entry *entry, int array_len, const int *array_number)</code></strong></p>
<p>Set the param entry's number array value. The entry's <code>value_array_double</code>, 
<code>value_array_float</code>, <code>value_array_int</code> fields are set in the same time.</p>
</li>
<li>
<p><strong><code>void ln_param_set_array_string(ln_param_entry *entry, int array_len, const char **array_string)</code></strong></p>
<p>Set the param entry's string array value.</p>
</li>
<li>
<p><strong><code>void ln_param_set_array_bool(ln_param_entry *entry, int array_len, const ln_bool *array_bool)</code></strong></p>
<p>Set the param entry's bool array value.</p>
</li>
</ul>
<p>The param list supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_list *ln_param_list_append_empty(ln_list *list, const char *arg_name, ln_param_type ptype)</code></strong></p>
<p>Append an empty param entry to the param list. Entry values are initialized
to zeros.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_string(ln_list *list, const char *arg_name, const char *string)</code></strong></p>
<p>Append a string param entry to the param list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_number(ln_list *list, const char *arg_name, double number)</code></strong></p>
<p>Append a number param entry to the param list. Numbers are set in a 
saturation manner.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_double(ln_list *list, const char *arg_name, double number)</code></strong></p>
<p>Append a double param entry to the param list. Numbers are set in a 
saturation manner.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_float(ln_list *list, const char *arg_name, float number)</code></strong></p>
<p>Append a float param entry to the param list. Numbers are set in a 
saturation manner.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_int(ln_list *list, const char *arg_name, int number)</code></strong></p>
<p>Append an int param entry to the param list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_bool(ln_list *list, const char *arg_name, ln_bool bool_value)</code></strong></p>
<p>Append a bool param entry to the param list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_null(ln_list *list, const char *arg_name)</code></strong></p>
<p>Append a null param entry to the param list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_array_string(ln_list *list, const char *arg_name, int array_len, const char **array_string)</code></strong></p>
<p>Append a string array param entry to the param list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_array_number(ln_list *list, const char *arg_name, int array_len, const double *array_number)</code></strong></p>
<p>Append a number array param entry to the param list. Numbers are set in a 
saturation manner.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_array_double(ln_list *list, const char *arg_name, int array_len, const double *array_number)</code></strong></p>
<p>Append a double array param entry to the param list. Numbers are set in a 
saturation manner.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_array_float(ln_list *list, const char *arg_name, int array_len, const float *array_number)</code></strong></p>
<p>Append a float array param entry to the param list. Numbers are set in a 
saturation manner.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_array_int(ln_list *list, const char *arg_name, int array_len, const int *array_int)</code></strong></p>
<p>Append an int array param entry to the param list.</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_append_array_bool(ln_list *list, const char *arg_name, int array_len, const ln_bool *array_bool)</code></strong></p>
<p>Append a bool array param entry to the param list.</p>
</li>
<li>
<p><strong><code>void ln_param_list_free(ln_list *list)</code></strong></p>
<p>Free a param list, as well as the array values (if array values are set).</p>
</li>
<li>
<p><strong><code>ln_list *ln_param_list_copy(ln_list *list)</code></strong></p>
<p>Copy a param list.</p>
</li>
<li>
<p><strong><code>ln_param_entry *ln_param_list_find(ln_list *list, const char *arg_name)</code></strong></p>
<p>Find a param entry with its arg name.</p>
</li>
<li>
<p><strong><code>ln_param_entry *ln_param_list_find2(ln_list *list, const char *arg_name1, const char *arg_name2)</code></strong></p>
<p>Find a param entry with its arg name. The arg name is assembled as
<code>{arg_name1}_{arg_name2}</code>.</p>
</li>
<li>
<p><strong><code>int ln_param_list_length(ln_list *list)</code></strong></p>
<p>Return the param list's length.</p>
</li>
<li>
<p><strong><code>int ln_param_list_unique_arg_name(ln_list *list, char *buf, const char *prefix)</code></strong></p>
<p>Create an arg name that is unique in the param list.
The arg name is prefixed with <code>prefix</code> and subfixed with a serial number,
so that unique names will be created for a same prefix.
The arg name' length should be less than <code>LN_MAX_NAME_LEN</code>. If its length
exceeds that limit, an internal error will be emited and the program will 
abort. The arg name  will be printed in <code>buf</code>. The return value is the 
subfixed number.</p>
</li>
</ul>
<h2 id="operator">Operator<a class="headerlink" href="#operator" title="Permanent link">&para;</a></h2>
<p>LightNet use <code>ln_op</code> to represent an operator, which receives some input tensors
and compute the output tensors according to its parameters.
A <code>ln_op</code> has its own life cycle, as showned below.</p>
<p><img style="transform:scale(0.7)" src=../img/op_state.png></p>
<p><code>ln_op</code> has 4 states in its lift cycle: <strong>init</strong>, <strong>checked</strong>, <strong>ready</strong>, <strong>end</strong>.
After created, a <code>ln_op</code> is in the <strong>init</strong> state. It has to execute its <code>pre_run</code>
function to check the validity of its input tensors and parameters, define 
its output tensors' shape, data type and so on, register its output tensors in the
tensor table, and then enter the <strong>checked</strong> state. 
For most operators, <strong>checked</strong> state is equivalent to <strong>ready</strong> state,
while there are some operators that need to execute its <code>static_run</code> function 
first to initialize their private data. 
In the <strong>ready</strong> state, an operator can execute its <code>run</code> function over and 
over again to do its real computation work. 
Or it can execute its <code>post_run</code> function to finalize its life cycle, 
free all the private memory it allocated in its life cycle, unregister its
output tensors from the tensor table, and enter the <strong>end</strong> state, where the
LightNet context can safely remove this operator from the operator table and
the data flow graph.</p>
<p><code>ln_op</code> has those 4 state-transfer functions in its C struct as function
pointers, which has the same prototype <code>ln_op_func</code>:</p>
<div class="codehilite"><pre><span></span><span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ln_op_func</span><span class="p">)</span> <span class="p">(</span><span class="n">ln_op_arg</span> <span class="o">*</span><span class="n">op_arg</span><span class="p">);</span>
<span class="k">typedef</span> <span class="nf">size_t</span> <span class="p">(</span><span class="o">*</span><span class="n">ln_op_offset_func</span><span class="p">)</span> <span class="p">(</span><span class="n">ln_op_arg</span> <span class="o">*</span><span class="n">op_arg</span><span class="p">,</span> <span class="n">ln_tensor_entry</span> <span class="o">*</span><span class="n">te</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">ln_op</span> <span class="p">{</span>
    <span class="n">ln_op_arg</span>          <span class="o">*</span><span class="n">op_arg</span><span class="p">;</span>
    <span class="n">ln_op_func</span>          <span class="n">pre_run</span><span class="p">;</span>
    <span class="n">ln_op_func</span>          <span class="n">static_run</span><span class="p">;</span>
    <span class="n">ln_op_func</span>          <span class="n">run</span><span class="p">;</span>
    <span class="n">ln_op_func</span>          <span class="n">post_run</span><span class="p">;</span>
    <span class="n">ln_op_offset_func</span>   <span class="n">calc_offset</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_op</span> <span class="n">ln_op</span><span class="p">;</span>
</pre></div>


<p>Besides <code>ln_op_func</code>, there is another <code>ln_op_offset_func</code> used in some 
operators that hace to determine their output tensors' data address offsets
according to their input tensors.</p>
<p>Those functions all has a <code>ln_op_arg</code> as their argument, through which they can
access and manipulate the operators' input tensors (<code>tensors_in</code>), output tensors
(<code>tensors_out</code>) and parameters (<code>params</code>). Besides, <code>ln_op_arg</code> has a <code>priv</code> 
field reserved for the operators' private data. Operators can define
a private struct in their defination C file, stores its private data in it and
assign <code>priv</code> with the private struct's pointer to pass it on and use it in
different state-transfer functions.</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="n">ln_op_arg</span> <span class="p">{</span>
    <span class="kt">char</span>                 <span class="o">*</span><span class="n">name</span><span class="p">;</span>           <span class="cm">/* operator name */</span>
    <span class="kt">char</span>                 <span class="o">*</span><span class="n">optype</span><span class="p">;</span>         <span class="cm">/* operator type */</span>
    <span class="kt">char</span>                 <span class="o">*</span><span class="n">arch</span><span class="p">;</span>           <span class="cm">/* backend architecture to run on */</span>
    <span class="n">ln_list</span>              <span class="o">*</span><span class="n">tensors_in</span><span class="p">;</span>     <span class="cm">/* input tensors */</span>
    <span class="n">ln_list</span>              <span class="o">*</span><span class="n">tensors_out</span><span class="p">;</span>    <span class="cm">/* output tensors */</span>
    <span class="n">ln_list</span>              <span class="o">*</span><span class="n">params</span><span class="p">;</span>         <span class="cm">/* parameters */</span>
    <span class="n">ln_hash</span>              <span class="o">*</span><span class="n">tensor_table</span><span class="p">;</span>   <span class="cm">/* tensor table of the context */</span>
    <span class="kt">void</span>                 <span class="o">*</span><span class="n">priv</span><span class="p">;</span>           <span class="cm">/* for other private data storage */</span>
    <span class="k">const</span> <span class="kt">char</span>          <span class="o">**</span><span class="n">in_arg_names</span><span class="p">;</span>   <span class="cm">/* NULL terminated array, as belows */</span>
    <span class="k">const</span> <span class="kt">char</span>          <span class="o">**</span><span class="n">out_arg_names</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span>          <span class="o">**</span><span class="n">param_arg_names</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">ln_param_type</span>  <span class="o">*</span><span class="n">param_ptypes</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">ln_op_arg</span> <span class="n">ln_op_arg</span><span class="p">;</span>
</pre></div>


<p><code>ln_op</code> generally supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_op *ln_op_create_from_proto(const ln_op *op_proto, const char *name, ln_list *tensors_in, ln_list *tensors_out, ln_list *params, ln_hash *tensor_table)</code></strong></p>
<p>Create an operator from a "proto" operator <code>op_proto</code>. The newly created operator
will have the same function pointers (<code>pre_run</code>, <code>run</code>, etc) as <code>op_proto</code>, with
its own <code>name</code>, <code>tensors_in</code>, <code>tensors_out</code>, <code>params</code>, and a <code>tensor_table</code>
pointer of the context passed from the caller. <code>op_proto</code> generally are found
from the global hash table <code>LN_ARCH.op_proto_table</code> with its operator type as 
the key.</p>
</li>
<li>
<p><strong><code>void ln_op_free(ln_op *op)</code></strong></p>
<p>Free an operator.</p>
</li>
<li>
<p><strong><code>void ln_op_free_lists_too(ln_op *op)</code></strong></p>
<p>Free an operator, as well as its <code>tensors_in</code>, <code>tensors_out</code> and <code>params</code>.</p>
</li>
<li>
<p><strong><code>ln_op *ln_op_create_with_names(const ln_op *op_proto, ln_hash *tensor_table)</code></strong></p>
<p>Create an operator and its <code>tensors_in</code>, <code>tensors_out</code> and <code>params</code> as well,
with auto-generated unique operator name and output tensor names in the scope
of the context. Input tensor names are inited with empty string (""), and
parameters are inited with empty value (zeroed number or <code>NULL</code> string or
<code>NULL</code> array). 
The meta information of the operator used to create those 
stuff is found in <code>ln_op_arg</code>'s <code>in_arg_names</code>, <code>out_arg_names</code>, 
<code>param_arg_names</code>, <code>param_ptypes</code>, etc.
This function is mainly used in optimization pass where LightNet will 
generate optimized new operators to replace old ones.</p>
</li>
<li>
<p><strong><code>ln_op *ln_op_create_with_opname(const ln_op *op_proto, ln_hash *tensor_table)</code></strong></p>
<p>Create an operator with auto-generated unique operator name in the scope of
the context.</p>
</li>
<li>
<p><strong><code>ln_op *ln_op_copy(const ln_op *op)</code></strong></p>
<p>Copy an operator.</p>
</li>
<li>
<p><strong><code>ln_op *ln_op_copy_to_optype(ln_hash *op_proto_table, const ln_op *op, const char *new_optype)</code></strong></p>
<p>Copy an operator's input/output tensors and parameters to a newly created
operator of a new operator type <code>new_optype</code>. Generally used in the simple 
replacement from one optype to another in optimization pass, such as
replacing <code>conv</code> with <code>conv_cuda</code>.</p>
</li>
<li>
<p><strong><code>ln_tensor_entry *ln_op_find_tensor_entry(const ln_op *op, const char *arg_name)</code></strong></p>
<p>Find an operator's input or output tensor entry with the entry's <code>arg_name</code>.</p>
</li>
<li>
<p><strong><code>ln_tensor_list_entry *ln_op_find_tensor_list_entry(const ln_op *op, const char *arg_name)</code></strong></p>
<p>Find an operator's input or output tensor list entry with the entry's <code>arg_name</code>.</p>
</li>
</ul>
<p>The are both an operator table and an operator list existing in a LightNet context.
While the former has the ownership of all operators, the latter retains a linear
form of the operators, which contains the execution order of the operators.</p>
<p>The operator list supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_list *ln_op_list_create_from_array(ln_op **op_array)</code></strong></p>
<p>Create an operator list from an <code>NULL</code> terminated operator array.</p>
</li>
<li>
<p><strong><code>void ln_op_list_free(ln_list *op_list)</code></strong></p>
<p>Free an operator list.</p>
</li>
<li>
<p><strong><code>void ln_op_list_free_lists_too(ln_list *ops)</code></strong></p>
<p>Free an operator list, as well as the operators' tensor lists and
parameter list.</p>
</li>
<li>
<p><strong><code>ln_op *ln_op_list_find_by_optype(ln_list *ops, const char *optype)</code></strong></p>
<p>Find the first operator from an operator list that has <code>optype</code> as its
operator type.</p>
</li>
<li>
<p><strong><code>ln_op *ln_op_array_find_by_optype(ln_op *ops[], const char *optype)</code></strong></p>
<p>Find the first operator from an <code>NULL</code> terminated operator array that
has <code>optype</code> as its operator type.</p>
</li>
<li>
<p><strong><code>ln_op *ln_op_list_find_by_name(ln_list *ops, const char *name)</code></strong></p>
<p>Find the first operator from an operator list that has <code>name</code> as its
operator name.</p>
</li>
<li>
<p><strong><code>void ln_op_list_do_pre_run(ln_list *ops)</code></strong></p>
<p>Execute the <code>pre_run</code> functions of the operators in <code>ops</code> in order.</p>
</li>
<li>
<p><strong><code>void ln_op_list_do_static_run(ln_list *ops)</code></strong></p>
<p>Execute the <code>static_run</code> functions of the operators in <code>ops</code> in order.</p>
</li>
<li>
<p><strong><code>void ln_op_list_do_run(ln_list *ops)</code></strong></p>
<p>Execute the <code>run</code> functions of the operators in <code>ops</code> in order.</p>
</li>
<li>
<p><strong><code>void ln_op_list_do_post_run(ln_list *ops)</code></strong></p>
<p>Execute the <code>post_run</code> functions of the operators in <code>ops</code> in order.</p>
</li>
<li>
<p><strong><code>char *ln_op_list_new_opname(const ln_list *ops, const char *prefix)</code></strong></p>
<p>Create an unique operator name in the operator list <code>ops</code> with <code>prefix</code>.
Return the newly allocated name string.</p>
</li>
</ul>
<p>The operator table supports the following operations:</p>
<ul>
<li>
<p><strong><code>ln_hash *ln_op_table_create(void)</code></strong></p>
<p>Create an empty operator table.</p>
</li>
<li>
<p><strong><code>int ln_op_table_insert(ln_hash *table, ln_op *op)</code></strong></p>
<p>Insert an operator to the table.</p>
</li>
<li>
<p><strong><code>int ln_op_table_remove(ln_hash *table, const char *name)</code></strong></p>
<p>Remove an operator from the table. The operator table will free the operator,
its tensor lists and parameter list when removing it from the table.</p>
</li>
<li>
<p><strong><code>ln_op *ln_op_table_find(ln_hash *table, const char *name)</code></strong></p>
<p>Find an operator from the table with its name.</p>
</li>
<li>
<p><strong><code>void ln_op_table_free(ln_hash *table)</code></strong></p>
<p>Free an operator table, as well as its operators.</p>
</li>
<li>
<p><strong><code>void ln_op_table_vset_param(ln_hash *table, const char *opname, const char *pname, va_list ap)</code></strong></p>
<p>Set an operator's parameter in the operator table.
Used in variable-length functions.</p>
</li>
<li>
<p><strong><code>void ln_op_table_set_param(ln_hash *table, const char *opname, const char *pname, ...)</code></strong></p>
<p>Set an operator's parameter with operator name <code>opname</code> in the operator table
and parameter argument name <code>pname</code> in the parameter list.
The function argument after <code>pname</code> should be a parameter value with an 
appropriate data type consistent with the according parameter.</p>
</li>
</ul>
<p>There are also a bunch of macros designated for the validity checking of tensors
and parameters in <code>pre_run</code> function. </p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Those convinent macros should <strong>only</strong> used in a <code>pre_run</code> function 
because of the function arguments they required. 
Normally we shouldn't use those kind of error handling routines in
other state-transfer functions, where errors should be considered
as bugs.
If there is more error handling work, please write the code yourself
instead of using those macros.</p>
</div>
<ul>
<li>
<p><strong><code>ln_opck(level, condition, msg_fmt, varg...)</code></strong></p>
<p>If <code>condition</code> not satisfied, emit message defined by printf-liked arguments 
<code>msg_fmt</code>and <code>varg...</code>, according to message level <code>level</code> (an enum defined in 
<code>ln_msg.h</code>).</p>
</li>
<li>
<p><strong><code>ln_opck_satisfy_msg(condition, msg_fmt, varg...)</code></strong></p>
<p>Emit error message if <code>condition</code> not satisfied and exit.</p>
</li>
<li>
<p><strong><code>ln_opck_satisfy(condition)</code></strong></p>
<p>Emit error message if <code>condition</code> not satisfied and exit.</p>
</li>
<li>
<p><strong><code>ln_opck_param_exist(entry, arg_name)</code></strong></p>
<p>Check if a param entry exists. <code>entry</code> should be returned by
<code>ln_param_list_find(op_arg-&gt;params, arg_name)</code>.</p>
</li>
<li>
<p><strong><code>ln_opck_param_type(entry, param_type)</code></strong></p>
<p>Check if a param entry's type is equal to <code>param_type</code>.
<code>param_type</code> is an enum <code>of ln_param_type</code> defined in <code>ln_param.h</code>.
<code>entry</code> should have been checked with <code>ln_opck_param_exist</code>.</p>
</li>
</ul>
<p>The following macros check if a number param entry's value is equal to (<code>eq</code>), 
greater than (<code>gt</code>), greater than or equal to (<code>ge</code>), less than (<code>lt</code>),
less than or equal to (<code>le</code>), or not equal to (<code>ne</code>) the number <code>expect</code>.
<code>entry</code> should have been checked with <code>ln_opck_param_exist</code>.</p>
<ul>
<li><strong><code>ln_opck_param_int_eq(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_int_gt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_int_ge(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_int_lt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_int_le(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_int_ne(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_float_eq(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_float_gt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_float_ge(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_float_lt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_float_le(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_float_ne(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_double_eq(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_double_gt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_double_ge(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_double_lt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_double_le(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_double_ne(entry, expect)</code></strong></li>
</ul>
<p>The following macros check if an array param entry's value's length is
equal to (<code>eq</code>), greater than (<code>gt</code>), greater than or equal to (<code>ge</code>), 
less than (<code>lt</code>), less than or equal to (<code>le</code>), or not equal to (<code>ne</code>)
the length <code>expect_len</code>. 
<code>entry</code> should have been checked with <code>ln_opck_param_exist</code>.</p>
<ul>
<li><strong><code>ln_opck_param_array_len_eq(entry, expect_len)</code></strong></li>
<li><strong><code>ln_opck_param_array_len_gt(entry, expect_len)</code></strong></li>
<li><strong><code>ln_opck_param_array_len_ge(entry, expect_len)</code></strong></li>
<li><strong><code>ln_opck_param_array_len_lt(entry, expect_len)</code></strong></li>
<li><strong><code>ln_opck_param_array_len_le(entry, expect_len)</code></strong></li>
</ul>
<p>The following macros check if a number array param entry's values are all
equal to (<code>eq</code>), greater than (<code>gt</code>), greater than or equal to (<code>ge</code>), 
less than (<code>lt</code>), less than or equal to (<code>le</code>), or not equal to (<code>ne</code>) 
the number <code>expect</code>.
<code>entry</code> should have been checked with <code>ln_opck_param_exist</code>.</p>
<ul>
<li><strong><code>ln_opck_param_array_int_eq(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_int_gt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_int_ge(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_int_lt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_int_le(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_int_ne(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_float_eq(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_float_gt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_float_ge(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_float_lt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_float_le(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_float_ne(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_double_eq(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_double_gt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_double_ge(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_double_lt(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_double_le(entry, expect)</code></strong></li>
<li><strong><code>ln_opck_param_array_double_ne(entry, expect)</code></strong></li>
</ul>
<p>The following macros check if the length of the parameter list (<code>list_len</code>)
is equal to (<code>eq</code>), greater than (<code>gt</code>), greater than or equal to (<code>ge</code>), 
less than (<code>lt</code>), less than or equal to (<code>le</code>), or not equal to (<code>ne</code>) 
the length <code>expect_len</code>.
<code>list_len</code> should be returned by <code>ln_param_list_length(op_arg-&gt;params)</code>.</p>
<ul>
<li><strong><code>ln_opck_params_len_eq(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_params_len_gt(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_params_len_ge(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_params_len_lt(list_len, expect_len)</code></strong></li>
<li>
<p><strong><code>ln_opck_params_len_le(list_len, expect_len)</code></strong></p>
</li>
<li>
<p><strong><code>ln_opck_tensor_in_exist(entry, arg_name)</code></strong></p>
<p>Check if an input tensor list entry exists. <code>entry</code> should be returned by
<code>ln_tensor_list_find_by_arg_name(op_arg-&gt;tensors_in, arg_name)</code>.</p>
</li>
</ul>
<p>The following macros check if the length of the input tensor list (<code>list_len</code>)
is equal to (<code>eq</code>), greater than (<code>gt</code>), greater than or equal to (<code>ge</code>), 
less than (<code>lt</code>), less than or equal to (<code>le</code>), or not equal to (<code>ne</code>) 
the length <code>expect_len</code>.
<code>list_len</code> should be returned by <code>ln_tensor_list_length(op_arg-&gt;tensors_in)</code>.</p>
<ul>
<li><strong><code>ln_opck_tensors_in_len_eq(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_tensors_in_len_gt(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_tensors_in_len_ge(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_tensors_in_len_lt(list_len, expect_len)</code></strong></li>
<li>
<p><strong><code>ln_opck_tensors_in_len_le(list_len, expect_len)</code></strong></p>
</li>
<li>
<p><strong><code>ln_opck_tensor_out_exist(entry, arg_name)</code></strong></p>
<p>Check if an output tensor list entry exists. <code>entry</code> should be returned by
<code>ln_tensor_list_find_by_arg_name(op_arg-&gt;tensors_out, arg_name)</code>.</p>
</li>
</ul>
<p>The following macros check if the length of the output tensor list (<code>list_len</code>)
is equal to (<code>eq</code>), greater than (<code>gt</code>), greater than or equal to (<code>ge</code>), 
less than (<code>lt</code>), less than or equal to (<code>le</code>), or not equal to (<code>ne</code>) 
the length <code>expect_len</code>.
<code>list_len</code> should be returned by <code>ln_tensor_list_length(op_arg-&gt;tensors_out)</code>.</p>
<ul>
<li><strong><code>ln_opck_tensors_out_len_eq(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_tensors_out_len_gt(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_tensors_out_len_ge(list_len, expect_len)</code></strong></li>
<li><strong><code>ln_opck_tensors_out_len_lt(list_len, expect_len)</code></strong></li>
<li>
<p><strong><code>ln_opck_tensors_out_len_le(list_len, expect_len)</code></strong></p>
</li>
<li>
<p><strong><code>ln_opck_tensor_not_defined(entry, entry_name)</code></strong></p>
<p>Check if the tensor entry <code>entry</code> has <em>not</em> been defined by another
operator so far. "defined" means an operator has created the tensor
and inserted the tensor entry in the tensor table.
<code>entry</code> should be returned by
<code>ln_tensor_table_find(op_arg-&gt;tensor_table, entry_name)</code>, where <code>entry_name</code>
is the <code>ln_tensor_entry</code>'s name to be looked up.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_defined(entry, entry_name)</code></strong></p>
<p>Check if the tensor entry <code>entry</code> has been defined by another
operator so far.
<code>entry</code> should be returned by
<code>ln_tensor_table_find(op_arg-&gt;tensor_table, entry_name)</code>, where <code>entry_name</code>
is the <code>ln_tensor_entry</code>'s name to be looked up.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_ndim(entry, expect_ndim)</code></strong></p>
<p>Check if the tensor in <code>entry</code> has the number of dimensions equal to
<code>expect_ndim</code>.
<code>entry</code> should have been checked with <code>ln_opck_tensor_defined</code>.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_len(entry, expect_len)</code></strong></p>
<p>Check if the tensor in <code>entry</code> has the number of elements equal to
<code>expect_len</code>.
<code>entry</code> should have been checked with <code>ln_opck_tensor_defined</code>.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_issameshape(entry1, entry2)</code></strong></p>
<p>Check if the tensor in <code>entry1</code> has the same shape with the tensor in
<code>entry2</code>.
Both <code>entry1</code> and <code>entry2</code> should have been checked with <code>ln_opck_tensor_defined</code>.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_issametype(entry1, entry2)</code></strong></p>
<p>Check if the tensor in <code>entry1</code> has the same data type with the tensor in
<code>entry2</code>.
Both <code>entry1</code> and <code>entry2</code> should have been checked with <code>ln_opck_tensor_defined</code>.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_isstatic(entry)</code></strong></p>
<p>Check if the tensor in <code>entry</code> is static.
<code>entry</code> should have been checked with <code>ln_opck_tensor_defined</code>.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_isnotstatic(entry)</code></strong></p>
<p>Check if the tensor in <code>entry</code> is <em>not</em> static.
<code>entry</code> should have been checked with <code>ln_opck_tensor_defined</code>.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_mtype_eq(entry, mem_type)</code></strong></p>
<p>Check if the tensor in <code>entry</code> has the memory type equals to <code>mem_type</code>.
<code>entry</code> should have been checked with <code>ln_opck_tensor_defined</code>.</p>
</li>
<li>
<p><strong><code>ln_opck_tensor_dtype_eq(entry, data_type)</code></strong></p>
<p>Check if the tensor in <code>entry</code> has the data type equals to <code>data_type</code>.
<code>entry</code> should have been checked with <code>ln_opck_tensor_defined</code>.</p>
</li>
</ul>
<h2 id="data-flow-graph">Data Flow Graph<a class="headerlink" href="#data-flow-graph" title="Permanent link">&para;</a></h2></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../js/base.js" defer></script>
        <script src="../js/baidu_analyse.js" defer></script>
        <script src="../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
